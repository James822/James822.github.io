
[{"content":"","date":"14 December 2025","externalUrl":null,"permalink":"/","section":"James Spratt","summary":"","title":"James Spratt","type":"page"},{"content":"","date":"14 December 2025","externalUrl":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects","type":"projects"},{"content":"","date":"14 December 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"In a previous post I made a tutorial showing how to get a window open on linux/X11 with an OpenGL context. I\u0026rsquo;d like to make the same tutorial but for windows now, so here it is.\nThis tutorial follows the same format as the last one, so I won\u0026rsquo;t really go into too much detail on things that I\u0026rsquo;ve already covered. I\u0026rsquo;m moreso only going to outline the windows/win32 aspects here, but don\u0026rsquo;t worry, the full source code is available here in my github repository.\nJust like the last tutorial, we\u0026rsquo;ll be using C to do everything, but you can also follow along in C++ with only a few modifications.\nWin32 # Unlike linux, everything we\u0026rsquo;ll need for this tutorial is under the win32 API. The win32 API is the programming interface to the windows operating system. It gives us the ability to perform file I/O, allocate memory, and namely: create windows.\nAs opposed to linux (or rather linux distributions), the windowing system is not seperate from the kernel or OS interface, but is provided as an integral part of win32. We\u0026rsquo;ll shortly see the functions we can use to create and manage windows.\nIf you had already read my previous tutorial for making a window on linux with GLX and X11, then win32 essentially combines all these things together into one interface. The equivalent to GLX on windows is called \u0026ldquo;WGL\u0026rdquo;, or the \u0026ldquo;Windows Extension to OpenGL\u0026rdquo;. There is no equivalent to a windowing system like X11 or wayland, as the windowing system is an integral part of win32.\nDocumentation # The primary source of documentation is MSDN (Microsoft Developer Network). Technically, MSDN was removed and integrated into a new space called \u0026ldquo;Microsoft Learn\u0026rdquo;, but everyone still refers to this portion of Microsoft Learn as what it used to be, which is MSDN.\nUnfortunately, Microsft Learn/MSDN is very disorganized. I would provide you a link, but that would be more unhelpful than just providing a few select links on specific topics.\nAlong with MSDN, you should also have the OpenGL registry on hand.\nCompiling/Building on Windows with MSVC # MSVC or the \u0026ldquo;Microsoft Visual C++\u0026rdquo; compiler is the main C/C++ compiler for windows which we will be using. Even though it only has \u0026ldquo;C++\u0026rdquo; in the title, it also supports C compilation. When it comes to microsoft, almost nothing is named what it should be, and everything seems to be almost deliberately confusing. Bear with me, as it only gets worse the further into it you go. Many of the MSDN docs will refer to \u0026ldquo;C++\u0026rdquo; tutorials or references, but these also apply to plain C as well.\nMSVC is the compiler used in Visual Studio, and typically, people invoke it when they use the Visual Studio IDE. If you want to use VS that\u0026rsquo;s up to you, but I\u0026rsquo;ll demonstrate how to use MSVC from the command line directly which I find be easier to use, and it allows you to use whatever IDE you like. For this section, the primary reference will be this MSDN documentation.\nThe first thing you need to do is grab the \u0026ldquo;Build Tools for Visual Studio\u0026rdquo; which is referenced in the MSDN doc, and can be found here. This will give you the Visual Studio installer, which you should launch. You\u0026rsquo;re going to want to select the \u0026ldquo;Desktop development with C++\u0026rdquo; install package, which is again poorly named, considering that it also gives us access to just plain C development tools. This install option is most likely all you\u0026rsquo;ll need, but check the other options to see if you need something else. Again, just like we stated before, many of the tutorials/docs are named for C++ but are also for C as well, so don\u0026rsquo;t worry.\nIn order for these build tools to work, a lot of environment variables need to be set correctly, which in my opinion is a very bad design decision on the behalf of windows. Thankfully, they at least provided a fix for this issue by giving us our choice of specific developer CMDs, or by using a vcvars\u0026lt;\u0026gt;.bat shell script to setup and configure any CMD for proper use in compiling with MSVC. We will go with the vcvars\u0026lt;\u0026gt;.bat option for this tutorial, but you can also just use one of the developer command prompts which does the same thing.\nUnfortunately, all of these configurations and environment variables are specific to the machine/installation that you are building on, so you can\u0026rsquo;t just copy the developer command prompts or vcvars\u0026lt;\u0026gt;.bat files over to another machine/installation and expect it to work, because it probably won\u0026rsquo;t. So basically, this process needs to be repeated for each installation of windows. The vcvars\u0026lt;\u0026gt;.bat files can also vary from version to version, so from one VS version to the next, the location of the file and contents of the file might change. That being said, major version updates for VS don\u0026rsquo;t come too often, but you should be looking to keep this process up to date at least a couple times or once per year.\nThe location of these vcvars\u0026lt;\u0026gt;.bat files is dependent, but I found mine for VS 2022 in the following location: C:\\Program Files (x86)\\Microsoft Visual Studio\\2022\\BuildTools\\VC\\Auxiliary\\Build. The location can also be in many different places, such as the \u0026ldquo;Progam Files\u0026rdquo; without the x86, but this one is the correct one because it is under the \u0026ldquo;BuildTools\u0026rdquo; directory which corresponds to the Build Tools that I just referenced earlier in this tutorial for you to make sure to install. Again, windows is awful for this as there\u0026rsquo;s multiple locations for these build files.\nWe\u0026rsquo;ll use the vcvars64.bat one because according to the MSDN docs: \u0026ldquo;Use the 64-bit x64-native tools to build 64-bit x64 code\u0026rdquo;, so it builds us 64-bit code. DO NOT cut or copy this file anywhere else. These files are so delicate and I fear that even chaging the file location could screw it up because of how delicate these things are. The cwd doesn\u0026rsquo;t seem to matter at least, but do not mess with these files as they are incredibly delicate as we will see soon.\nThen, run the vcvars\u0026lt;\u0026gt;.bat file only ONCE in the CMD you are using, then you can use the MSVC compiler. The vcvars\u0026lt;\u0026gt;.bat files are NOT meant to be run any more than ONE time in a given CMD, otherwise they will screw up the PATH environment variable among other environment variables. They will just add to it instead of properly changing it, so you can only run ONE of these per CMD window/instance and not more than once. A good idea would be to write a script that sets a variable to see if it has been run in your CMD already, so that it only runs it once.\nOnce this is done in your CMD, MSVC is now avaible to run with \u0026ldquo;cl\u0026rdquo; or \u0026ldquo;cl.exe\u0026rdquo; as the compiler, and \u0026ldquo;link\u0026rdquo; or \u0026ldquo;link.exe\u0026rdquo; as the linker. These will be valid for the rest of the lifetime of the CMD you are in.\nWindows SDK and Installing (OpenGL) Headers # Before we do anything else, we should also install headers.\nThe latest Windows SDK (also confusingly called \u0026ldquo;Windows Kits\u0026rdquo; for who knows what reason) is usually installed on your system when you install the Build Tools for Visual Studio as outlined above. The SDK contains many headers, such as the OpenGL headers, which we will need for this tutorial.\nOpenGL extension headers are not included for whatever reason (glext.h, wglext.h, etc.), so you need to manually install them yourself. Any headers you want to install can be done manually with this method:\nFind the location of the Windows SDK, which on my machine is installed in the location: C:\\Program Files (x86)\\Windows Kits\\, which is confusing as they use the name \u0026ldquo;Windows Kits\u0026rdquo; instead of what should be \u0026ldquo;Windows SDK\u0026rdquo;.\nI found the headers in the C:\\Program Files (x86)\\Windows Kits\\10\\ subfolder which probably refers to Windows 10 (as that is the OS being used at the time of writing this post). The headers, library files, and many other important files are here for windows development.\nFor example, the OpenGL headers are in the location: C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22621.0\\um\\gl\\ where 10.0.22621.0 is the latest SDK that was installed when installing the Build Tools for Visual Studio. You can drag and drop extension headers such as glext.h or wglext.h in here, and then it will add it to your system headers which will be recognized as \u0026lt;gl/glext.h\u0026gt; and \u0026lt;gl/wglext.h\u0026gt;. (NOTE: Windows/NTFS doesn\u0026rsquo;t care about case in filenames, so \u0026ldquo;Windows.h\u0026rdquo; = \u0026ldquo;windows.h\u0026rdquo; = \u0026ldquo;WINDOWS.h\u0026rdquo;, etc. By default, prefer lowercase).\nYou\u0026rsquo;ll need to add the khrplatform.h header as well to your system as glext.h depends on \u0026lt;khr/khrplatform.h\u0026gt; being a valid location. This is easy, just create a khr folder in the C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22621.0\\um\\ directory and then place the khrplatform.h file in that folder so that the location looks like this: C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.22621.0\\um\\khr\\khrplatform.h. Then, the system include \u0026lt;khr/khrplatform.h\u0026gt; or equivalently \u0026lt;KHR/khrplatform.h\u0026gt; will be recognized by MSVC.\nYou can also just place your headers in your local project folder, and then add the path to MSVC with the /I flag, but I prefer this method with installing it manually in the Windows SDK (or \u0026ldquo;Windows Kits\u0026rdquo;) location as it keeps it all in one place, and is current to the specific version of the SDK you use. If you get a new SDK version, you\u0026rsquo;ll need to repeat this process.\nStarter Code and Compilation with cl.exe (MSVC) # Once you have the headers installed and a CMD open and have run the vcvars\u0026lt;\u0026gt;.bat file (or if you have a developer command prompt, which does the same thing), type cl or cl.exe in your CMD and you should get output like this:\nMicrosoft (R) C/C++ Optimizing Compiler Version 19.43.34809 for x64 Copyright (C) Microsoft Corporation. All rights reserved. usage: cl [ option... ] filename... [ /link linkoption... ] Otherwise, if you get some kind of error like this:\n\u0026#39;cl\u0026#39; is not recognized as an internal or external command, operable program or batch file. Then that means you haven\u0026rsquo;t run the vcvars\u0026lt;\u0026gt;.bat file (or you aren\u0026rsquo;t using a developer CMD).\nOnce you have cl.exe available and ready, we can finally compile a basic starter \u0026ldquo;Hello World\u0026rdquo; program to make sure everything is setup correctly. Start with this C code and name it something like \u0026ldquo;win32_window.c\u0026rdquo;:\n/* Windows window and WGL/OpenGL example program. */ /* @@ we have to ignore all these errors because the windows.h header itself won\u0026#39;t even compile without error with \u0026#34;/Wall\u0026#34; in MSVC, which is quite ironic that microsoft\u0026#39;s own headers don\u0026#39;t compile without warning in their compiler. */ #pragma warning( push ) #pragma warning( disable : 4668 ) #include \u0026lt;windows.h\u0026gt; #include \u0026lt;windowsx.h\u0026gt; #pragma warning( pop ) /* @! */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;gl/gl.h\u0026gt; /* these two headers need to manually installed, windows only provides \u0026#34;gl/gl.h\u0026#34; as part of the Windows SDK (installed when you install the Build Tools for Visual Studio). You can grab both of these headers from the OpenGL registry: https://registry.khronos.org/OpenGL/index_gl.php */ #include \u0026lt;gl/glext.h\u0026gt; #include \u0026lt;gl/wglext.h\u0026gt; int main(void) { printf(\u0026#34;Hello World!\\n\u0026#34;); HINSTANCE hInstance = GetModuleHandleA(NULL); /* since we aren\u0026#39;t using wWinMain() or WinMain(), we need to grab the HINSTANCE with this function. */ int program_running = 1; int fullscreen = 1; /* set to \u0026#39;1\u0026#39; if you want fullscreen, \u0026#39;0\u0026#39; if you don\u0026#39;t */ /* @@ user variables */ const char* window_name = \u0026#34;win32 window\u0026#34;; int window_width = 960; int window_height = 540; /* @! */ return 0; } then, compile with this command:\ncl User32.lib Gdi32.lib Opengl32.lib win32_window.c Then run it with:\nwin32_window.exe and you should get \u0026ldquo;Hello World!\u0026rdquo; as output in your CMD.\nThe libraries User32.lib, Gdi32.lib, and Opengl32.lib are all required for what we are going to do. User32.lib is neccessary for some basic win32 functions, and the remaining two are necessary for creating an OpenGL context.\nDummy Window/Context # Before we jump into anything else, I need to make something clear about a certain quirk on windows that you need to be aware of when it comes to OpenGL.\nFor 2 reasons on windows, it is neccessary to create both a \u0026ldquo;dummy\u0026rdquo; window \u0026amp; GL context. We will need to first create the dummy window, get a dummy (legacy) OpenGL context, and then use that dummy GL context to load the necessary extension procedures to create a modern core-profile GL context.\nThe procedure that we need to create a modern core-profile OpenGL context is mainly wglCreateContextAttribsARB, and also a few others. The problem here is that we can\u0026rsquo;t load these extension procedures unless we already have an OpenGL context! The procedure loading function on windows is wglGetProcAddress, and it requires a context to be current in order to function properly. In fact, the MSDN docs say that the function pointers returned by wglGetProcAddress are only valid given a current-context, and it may not be valid for any other contexts.\nSo how do we solve this apparent Catch-22? The answer is that we are still able to create a legacy OpenGL context as windows provides legacy GL functions to do so, namely wglCreateContext. Once we have this GL context and have made it current, we can then use it to query for and load procedures that we use to create the new or modern OpenGL context, and then we can get rid of the old one.\nAlong with that, windows only allows us to set the pixel format of a window once. If we want to change the pixel format of window, we can\u0026rsquo;t. The only way to change pixel formats is to create a new window. Since it is required to set a pixel format for a window to get an OpenGL context, we need to set the pixel format of the window and then use that window to create the dummy (legacy) GL context. This would be all fine, except that modern GL context creation has extended pixel formats that we will want to support, with extension functions provided such as wglChoosePixelFormatARB to give us more options for pixel formats. So because of all those reasons, we also find it necessary to create a new window to take advantage of new pixel formats that come with modern GL.\nSo in short, because of both the nature of loading procedures requiring an existing context AND pixel formats only being able to be set once; we need a dummy window AND a dummy GL context, of which both we will destroy once we have the \u0026ldquo;real\u0026rdquo; window and \u0026ldquo;real\u0026rdquo; GL context.\nDummy Window/Context Creation # Finally we can start doing some real work!\nIn order to create the dummy window and dummy GL context, you can use this code:\n/* @@ creating dummy GL window */ const char* dummygl_window_class_name = \u0026#34;DUMMYGL_WINDOW_CLASS\u0026#34;; WNDCLASSA dummygl_wnd_class; dummygl_wnd_class.style = CS_OWNDC; dummygl_wnd_class.lpfnWndProc = DummyGL_WindowProc; dummygl_wnd_class.cbClsExtra = 0; dummygl_wnd_class.cbWndExtra = 0; dummygl_wnd_class.hInstance = hInstance; dummygl_wnd_class.hIcon = NULL; dummygl_wnd_class.hCursor = NULL; dummygl_wnd_class.hbrBackground = 0; dummygl_wnd_class.lpszMenuName = NULL; dummygl_wnd_class.lpszClassName = dummygl_window_class_name; if(RegisterClassA(\u0026amp;dummygl_wnd_class) == 0) { DWORD win32_error_val = GetLastError(); printf(\u0026#34;ERROR: RegisterClassA() failed to register window class: %s - win32 error code: %ld\\n\u0026#34;, dummygl_window_class_name, win32_error_val); } HWND dummygl_window_handle = CreateWindowA (dummygl_window_class_name, \u0026#34;dummygl_window\u0026#34;, WS_DISABLED, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL); if(dummygl_window_handle == NULL) { DWORD win32_error_val = GetLastError(); printf(\u0026#34;ERROR: CreateWindowA() failed to create dummygl window - win32 error code: %ld\\n\u0026#34;, win32_error_val); return 1; } HDC dummygl_DC = GetDC(dummygl_window_handle); if(dummygl_DC == NULL) { printf(\u0026#34;ERROR: GetDC() failed to get DC for dummygl window\\n\u0026#34;); return 1; } /* @! */ /* @@ creating dummy GL context */ /* it doesn\u0026#39;t matter what the pixel format descriptor members are, just as long as this gets us a context, so we just pick members that would give us a high chance of getting a context on every possible system */ PIXELFORMATDESCRIPTOR dummygl_pfd; dummygl_pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR); dummygl_pfd.nVersion = 1; dummygl_pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER; dummygl_pfd.iPixelType = PFD_TYPE_RGBA; dummygl_pfd.cColorBits = 32; dummygl_pfd.cRedBits = 0; dummygl_pfd.cRedShift = 0; dummygl_pfd.cGreenBits = 0; dummygl_pfd.cGreenShift = 0; dummygl_pfd.cBlueBits = 0; dummygl_pfd.cBlueShift = 0; dummygl_pfd.cAlphaBits = 0; dummygl_pfd.cAlphaShift = 0; dummygl_pfd.cAccumBits = 0; dummygl_pfd.cAccumRedBits = 0; dummygl_pfd.cAccumGreenBits = 0; dummygl_pfd.cAccumBlueBits = 0; dummygl_pfd.cAccumAlphaBits = 0; dummygl_pfd.cDepthBits = 24; dummygl_pfd.cStencilBits = 8; dummygl_pfd.cAuxBuffers = 0; dummygl_pfd.iLayerType = PFD_MAIN_PLANE; dummygl_pfd.bReserved = 0; dummygl_pfd.dwLayerMask = 0; dummygl_pfd.dwVisibleMask = 0; dummygl_pfd.dwDamageMask = 0; int dummygl_pixelformat_index = ChoosePixelFormat(dummygl_DC, \u0026amp;dummygl_pfd); if(dummygl_pixelformat_index == 0) { DWORD win32_error_val = GetLastError(); printf(\u0026#34;ERROR: ChoosePixelFormat() failed to get a pixel format that matched - win32 error code: %ld\\n\u0026#34;, win32_error_val); return 1; } if(SetPixelFormat(dummygl_DC, dummygl_pixelformat_index, \u0026amp;dummygl_pfd) != TRUE) { DWORD win32_error_val = GetLastError(); printf(\u0026#34;ERROR: SetPixelFormat() failed to set the pixel format - win32 error code: %ld\\n\u0026#34;, win32_error_val); return 1; } HGLRC dummygl_context = wglCreateContext(dummygl_DC); if(dummygl_context == NULL) { DWORD win32_error_val = GetLastError(); printf(\u0026#34;ERROR: wglCreateContext() failed to create a dummy GL context - win32 error code: %ld\\n\u0026#34;, win32_error_val); return 1; } if(wglMakeCurrent(dummygl_DC, dummygl_context) != TRUE) { DWORD win32_error_val = GetLastError(); printf(\u0026#34;ERROR: wglMakeCurrent() failed to make context current - win32 error code: %ld\\n\u0026#34;, win32_error_val); return 1; } /* @! */ The first we thing we need to do is create a window class for the dummy window and register it with RegisterClassA(). Window classes in win32 are basically just window information for a window class, they don\u0026rsquo;t really serve much of a purpose beyond the fact that they can be reused across more than one window. We won\u0026rsquo;t be doing such thing, so we\u0026rsquo;ll create the window class for our dummy window.\nWe also need to pass in a pointer to the RegisterClassA() function that specifies something called the \u0026ldquo;window procedure\u0026rdquo;, a special callback that we must register for each window. This window callback is a function called by the OS which receives all kinds of events or messages that we need to handle.\nSince this is a dummy window that we will destroy, we don\u0026rsquo;t actually need to worry about how to handle the window procedure so much, so we can just write the function with DefWindowProc() which is the \u0026ldquo;default window procedure\u0026rdquo; provided to us by win32 that automatically handles every message:\nLRESULT CALLBACK DummyGL_WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { return DefWindowProc(hwnd, uMsg, wParam, lParam); } Then, we can pass DummyGL_WindowProc to the RegisterClassA() which will register this window callback to the one used for any windows created with this window class. We will go over what the Window Procedure is and how to write it in more detail later, but for the dummy window, we just need default behaviour as we\u0026rsquo;ll never actually use the window for anything else besides getting a context. The user of this application will never see the dummy window.\nNext, we then create the dummy window with CreateWindowA(), and we also grab the window DC (device context) which is necessary for context creation.\nTo create an OpenGL context in windows, we need to first set a pixel format. We choose it first with ChoosePixelFormat(), and then set it with SetPixelFormat() which is set per-window. Even though we pass in the device context to this function, it refers to our window.\nRight from the MSDN docs:\nIf hdc references a window, calling the SetPixelFormat function also changes the pixel format of the window. Setting the pixel format of a window more than once can lead to significant complications for the Window Manager and for multithread applications, so it is not allowed. An application can only set the pixel format of a window one time. Once a window\u0026rsquo;s pixel format is set, it cannot be changed.\nSo this is what is behind the reason for needing a dummy window, as we will see that when we load the extension procedures for extension pixel formats, we need a fresh window to set a new pixel format.\nThe next thing we do after that is create the dummy context with the wgl function wglCreateContext() which just takes in our window DC. Then, we need to make it current with wglMakeCurrent() so that we can start loading procedures.\nLoading WGL Extension Procedures # Now that we have our (legacy) dummy GL context, we can load the important procedures that will be neccessary for a modern core-profile GL context.\nThere are three extensions that we need to create a new context: WGL_ARB_extensions_string, WGL_ARB_pixel_format, and WGL_ARB_create_context_profile.\nThe first extension, WGL_ARB_extensions_string, is important as it gives us the procedure wglGetExtensionsStringARB() which gives us the ability to query what extensions are available.\nUnfortunately, due to some oversight, wglGetExtensionsStringARB() is not provided statically, so we just have to load it and hope that it is present, otherwise we have no ability to query what extensions are available. This is also another Catch-22 situation, as we need the wglGetExtensionsStringARB() function to be present in order to query if extensions are present, including WGL_ARB_extensions_string. GLX handles this much better as there is a statically provided glXQueryExtensionsString which does the same thing.\nSo, we just try to load wglGetExtensionsStringARB() and hope that it is available. As for how to load extension procedures, we use the wgl function wglGetProcAddress().\nwglGetProcAddress() apparently does not function as documented in MSDN, as according to this Khronos wiki entry:\nWhile the MSDN documentation says that wglGetProcAddress returns NULL on failure, some implementations will return other values. 1, 2, and 3 are used, as well as -1.\nSo, we wrap wglGetProcAddress() in our function Load_WGL_Proc() like this:\n/* Loads the specified GL/WGL function with the name \u0026#34;proc_name\u0026#34; using wglGetProcAddress(). Returns NULL on failure, otherwise non-NULL for success. */ void* Load_WGL_Proc(const char* proc_name) { void* proc = NULL; proc = (void *)wglGetProcAddress(proc_name); if(proc == 0 || proc == (void *)1 || proc == (void *)2 || proc == (void *)3 || proc == (void *)-1) { return NULL; } return proc; } We also need a function to parse the extension string as it is a space-seperated list of extensions names (there are no spaces in an extension name). In python, this might be a simple one-liner, but in C, it takes a bit more work. My implementation is here, I call the function Check_Extension_Available():\n/* Returns 1 if extension is available, otherwise 0 if it is not present. This function expects \u0026#34;extensions_lists\u0026#34; to be a space seperated list of GL (or platform, e.g. WGL/GLX) extensions, and it searches extensions_lists to find if the extension \u0026#34;extensions\u0026#34; is within it. */ static int Check_Extension_Available(const char* extensions_list, const char* extension) { int i = 0; char c = extensions_list[i]; while(c != \u0026#39;\\0\u0026#39;) { if(c == extension[0]) { if(i \u0026gt; 0) { /* i \u0026gt; 0 (i != 0) means we need to ensure the previous char is a space */ if(extensions_list[i - 1] != \u0026#39; \u0026#39;) { break; } } /* now we check to see if the rest of the string after matches */ int equal = 1; int j = 0; while(extension[j] != \u0026#39;\\0\u0026#39;) { if(extensions_list[i + j] == \u0026#39;\\0\u0026#39;) { equal = 0; break; } if(extensions_list[i + j] != extension[j]) { equal = 0; break; } j += 1; } if(equal == 1 \u0026amp;\u0026amp; (extensions_list[i + j] == \u0026#39; \u0026#39; || extensions_list[i + j] == \u0026#39;\\0\u0026#39;) ) { return 1; } } i += 1; c = extensions_list[i]; } return 0; } I don\u0026rsquo;t claim this is the best or most secure, it\u0026rsquo;s just what I quickly wrote up.\nNow that we have that, we can finally load the procedures:\n/* @@ loading extensions to create our real Gl context. Now that we have a dummy context, we can load the necessary extension procedures in order to create the real context. */ /* the procedure wglGetExtensionsStringARB() is used to query extensions, but since it is itself part of an extension (WGL_ARB_extensions_string), we can\u0026#39;t use the procedure to query itself before we even know if it exists. So, we just have to try to load it. */ PFNWGLGETEXTENSIONSSTRINGARBPROC wglGetExtensionsStringARB = NULL; wglGetExtensionsStringARB = (PFNWGLGETEXTENSIONSSTRINGARBPROC) Load_WGL_Proc(\u0026#34;wglGetExtensionsStringARB\u0026#34;); if(wglGetExtensionsStringARB == NULL) { printf(\u0026#34;ERROR: failed to load wglGetExtensionsStringARB()\\n\u0026#34;); return 1; } const char * extensions_string = wglGetExtensionsStringARB(dummygl_DC); if(extensions_string == NULL) { DWORD win32_error_val = GetLastError(); printf(\u0026#34;ERROR: wglGetExtensionsStringARB() failed to get the extensions string - win32 (or or WGL_ARB_extensions_string extension) error code: %ld\\n\u0026#34;, win32_error_val); return 1; } if(Check_Extension_Available(extensions_string, \u0026#34;WGL_ARB_pixel_format\u0026#34;) != 1) { printf(\u0026#34;ERROR: WGL_ARB_pixel_format extension not found\\n\u0026#34;); return 1; } if(Check_Extension_Available(extensions_string, \u0026#34;WGL_ARB_create_context_profile\u0026#34;) != 1) { printf(\u0026#34;ERROR: WGL_ARB_create_context_profile extension not found\\n\u0026#34;); return 1; } /* These procedure pointers are neccessary to aquire/load in the dummy context, but the remainder of the WGL (and GL) extension procedures should be loaded with the actual context. wglGetExtensionsStringARB() should be loaded again with the new context, but these ones are only neccessary to for context creation, so we don\u0026#39;t need them again. */ PFNWGLGETPIXELFORMATATTRIBIVARBPROC wglGetPixelFormatAttribivARB = NULL; PFNWGLGETPIXELFORMATATTRIBFVARBPROC wglGetPixelFormatAttribfvARB = NULL; PFNWGLCHOOSEPIXELFORMATARBPROC wglChoosePixelFormatARB = NULL; PFNWGLCREATECONTEXTATTRIBSARBPROC wglCreateContextAttribsARB = NULL; wglGetPixelFormatAttribivARB = (PFNWGLGETPIXELFORMATATTRIBIVARBPROC) Load_WGL_Proc(\u0026#34;wglGetPixelFormatAttribivARB\u0026#34;); wglGetPixelFormatAttribfvARB = (PFNWGLGETPIXELFORMATATTRIBFVARBPROC) Load_WGL_Proc(\u0026#34;wglGetPixelFormatAttribfvARB\u0026#34;); wglChoosePixelFormatARB = (PFNWGLCHOOSEPIXELFORMATARBPROC) Load_WGL_Proc(\u0026#34;wglChoosePixelFormatARB\u0026#34;); wglCreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC) Load_WGL_Proc(\u0026#34;wglCreateContextAttribsARB\u0026#34;); if(wglGetPixelFormatAttribivARB == NULL) { printf(\u0026#34;ERROR: failed to load proc: \\\u0026#34;wglGetPixelFormatAttribivARB\\\u0026#34;\\n\u0026#34;); return 1; } if(wglGetPixelFormatAttribfvARB == NULL) { printf(\u0026#34;ERROR: failed to load proc: \\\u0026#34;wglGetPixelFormatAttribfvARB\\\u0026#34;\\n\u0026#34;); return 1; } if(wglChoosePixelFormatARB == NULL) { printf(\u0026#34;ERROR: failed to load proc: \\\u0026#34;wglChoosePixelFormatARB\\\u0026#34;\\n\u0026#34;); return 1; } if(wglCreateContextAttribsARB == NULL) { printf(\u0026#34;ERROR: failed to load proc: \\\u0026#34;wglCreateContextAttribsARB\\\u0026#34;\\n\u0026#34;); return 1; } /* @! */ The second extension: WGL_ARB_pixel_format, gives us the procedures needed to create new types of pixel formats mainly with the procedure: wglChoosePixelFormatARB().\nThe third extensions: WGL_ARB_create_context_profile, gives us the important function wglCreateContextAttribsARB() which is what is used to actually create the modern core-profile OpenGL context.\nNow we are ready to create the real GL context!\nWindow Procedure # Before we do indeed create the real window and real GL context, we need to revisit the window procedure.\nUnfortunately, win32 is designed in a way so that it is necessary to have a window procedure callback that you must define so that it can handle potentially thousands of different kinds of messages. A typical window procedure might look like the following:\nLRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { switch (uMsg) { case WM_DESTROY: PostQuitMessage(0); return 0; case WM_PAINT: { PAINTSTRUCT ps; HDC hdc = BeginPaint(hwnd, \u0026amp;ps); // All painting occurs here, between BeginPaint and EndPaint. FillRect(hdc, \u0026amp;ps.rcPaint, (HBRUSH) (COLOR_WINDOW+1)); EndPaint(hwnd, \u0026amp;ps); } return 0; } return DefWindowProc(hwnd, uMsg, wParam, lParam); } where you either decide to intercept messages yourself, or let them be handled by the Default Window Procedure DefWindowProc().\nMicrosoft doesn\u0026rsquo;t even document these messages properly, with their documentation being scattered all over MSDN and not in a central place. Luckily, the folks over at WINE have taken it upon themselves do to so which can be found here.\nWhat\u0026rsquo;s not so great is that the window procedure can be called by windows (the OS) at any time and there is no way of predicting when! Rather than just having a simple message loop that blocks until it gets messages, the creators behind win32 also opted to go for a callback design with the window procedure message, which is nothing less than an awful design choice no matter what historical context prompted it.\nThe window procedure can either be called in the message loop by DispatchMessage(), which is a function we will call (we\u0026rsquo;ll get to the message loop later), OR, it can be called at any point by the OS. There are essentially two different event-handling paradigms (callback/queued) that are both present in win32. This is the worst of both worlds, not the best.\nThere is also absolutely no clear and cut way to know what messages you should handle, whether you should intercept some and handle completely yourself, or if you should handle it and then pass it to the default window procedure - OR - if you should only use the default window procedure period. Since we don\u0026rsquo;t have the source code for DefWindowProc(), half the time we just have to guess what it does, as most of the documentation for it is in the MSDN description for a message and is usually vague and somtimes completely absent.\nWhat\u0026rsquo;s even worse is that if you choose not to handle some messages, your window or application will break in completely unpredictable ways, as the message model that win32 operates on is very odd in several places. Sometimes messages will be passed in for purely informational purposes (such as when a window is created), but you still have to return a specific value otherwise certain functions will break (such as CreateWindow()).\nWhat the OS is essentially doing is \u0026ldquo;recruiting\u0026rdquo; our process (specifically the thread the window was created in) to do the window processing that it should be handling itself. This is a terrible design decision and could have only ever been cooked up by microsoft. It is overly complex and very error-prone, with absolutely no benefit.\nRather than handling it in the OS (where it should be) a lot of critical default behaviour is offloaded onto your thread, which causes unexpected behaviour that can be bad in very subtle ways. See this link for example of how much of a headache this caused for the folks at SDL. This is just one particular example.\nAll of this might be acceptable if it was well-documented exactly what the default window procedure does, as we are essentially forced into calling it on our own process thread, rather than the OS handling itself (which it should). But of course, as we would expect, the documentation for DefWindowProc() is spread out all over MSDN for each message (there are thousands of messages!). Most of the time, only vague descriptions are given as to what the default window procedure does, which is next to useless.\nThankfully, the folks at WINE have once again come to the rescue and they have reverse engineered the default window procedure which can be found here.\nTo deal with all of this nonsense, we basically just have to call the default window procedure, and try to figure out which cases we need to handle ourselves. This is a tedious trial-and-error process and is unfortunately the only way to go. Once again, absolutely terrible design on the behalf of microsoft.\nOn the bright side, we can learn from existing codebases (such as the reverse-engineered one in WINE) for how to write our window procedures.\nThe implementation we will use for this tutorial is given here:\n/* main window procedure for our win32 window */ LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { /* printf(\u0026#34;MSG CODE: %u\\n\u0026#34;, uMsg); */ LRESULT result = 0; switch (uMsg) { /* @@ these are messages that we want to process ourselves */ case WM_PAINT: { printf(\u0026#34;WM_PAINT\\n\u0026#34;); ValidateRect(hwnd, NULL); /* validates the entire client region of the window so that the OS doesn\u0026#39;t keep spamming WM_PAINT messages and thus stalling our application message loop. */ } break; case WM_CLOSE: { printf(\u0026#34;WM_CLOSE\\n\u0026#34;); PostQuitMessage(0); } break; /* @! */ /* @@ mouse input */ case WM_LBUTTONDOWN: { printf(\u0026#34;WM_LBUTTONDOWN\\n\u0026#34;); } break; case WM_LBUTTONUP: { printf(\u0026#34;WM_LBUTTONUP\\n\u0026#34;); } break; case WM_MBUTTONDOWN: { printf(\u0026#34;WM_MBUTTONDOWN\\n\u0026#34;); } break; case WM_MBUTTONUP: { printf(\u0026#34;WM_MBUTTONUP\\n\u0026#34;); } break; case WM_RBUTTONDOWN: { printf(\u0026#34;WM_RBUTTONDOWN\\n\u0026#34;); } break; case WM_RBUTTONUP: { printf(\u0026#34;WM_RBUTTONUP\\n\u0026#34;); } break; case WM_XBUTTONDOWN: { printf(\u0026#34;WM_XBUTTONDOWN: \u0026#34;); if(GET_XBUTTON_WPARAM(wParam) == XBUTTON1) { printf(\u0026#34;XBUTTON1\u0026#34;); } else if(GET_XBUTTON_WPARAM(wParam) == XBUTTON2) { printf(\u0026#34;XBUTTON2\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } break; case WM_XBUTTONUP: { printf(\u0026#34;WM_XBUTTONUP: \u0026#34;); if(GET_XBUTTON_WPARAM(wParam) == XBUTTON1) { printf(\u0026#34;XBUTTON1\u0026#34;); } else if(GET_XBUTTON_WPARAM(wParam) == XBUTTON2) { printf(\u0026#34;XBUTTON2\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } break; case WM_MOUSEMOVE: { printf(\u0026#34;WM_MOUSEMOVE\\n\u0026#34;); int x_pos = GET_X_LPARAM(lParam); int y_pos = GET_Y_LPARAM(lParam); } break; case WM_MOUSEWHEEL: { printf(\u0026#34;WM_MOUSEWHEEL\\n\u0026#34;); } /* @! */ /* @@ keyboard Input */ case WM_SYSKEYDOWN: { printf(\u0026#34;WM_SYSKEYDOWN\\n\u0026#34;); } break; case WM_SYSKEYUP: { printf(\u0026#34;WM_SYSKEYUP\\n\u0026#34;); } break; case WM_KEYDOWN: { printf(\u0026#34;WM_KEYDOWN\\n\u0026#34;); if(wParam == VK_ESCAPE) { /* quit if user presses the ESC key */ PostQuitMessage(0); } } break; case WM_KEYUP: { printf(\u0026#34;WM_KEYUP\\n\u0026#34;); } break; case WM_CHAR: { printf(\u0026#34;WM_CHAR\\n\u0026#34;); } break; case WM_SYSCHAR: { printf(\u0026#34;WM_SYSCHAR\\n\u0026#34;); } break; /* @!*/ default: { result = DefWindowProc(hwnd, uMsg, wParam, lParam); /* result = 0; */ } break; } return result; } This minimal implementation has empty cases for all kinds of keyboard input and mouse input. The WM_PAINT message in particular is handled ourselves as we don\u0026rsquo;t want the default procedure painting our window. Since we will be using OpenGL for graphics, we only call ValidateRect() to let the OS know that the whole window reigon is \u0026ldquo;validated\u0026rdquo; so that it won\u0026rsquo;t continue to spam more WM_PAINT and stall our application.\nCreating the Real Window and Real GL Context # Now we can finally create the real window and real GL context!\nTo do so, use this code:\n/* @@ Creating the real window */ WNDCLASSEXA wnd_class; const char* window_class_name = \u0026#34;WINDOW_CLASS\u0026#34;; wnd_class.cbSize = sizeof(WNDCLASSEXA); wnd_class.style = CS_OWNDC; /* it\u0026#39;s probably neccessary to set CS_OWNDC flag for OpenGL context creation */ wnd_class.lpfnWndProc = WindowProc; wnd_class.cbClsExtra = 0; wnd_class.cbWndExtra = 0; wnd_class.hInstance = hInstance; wnd_class.hIcon = NULL; wnd_class.hCursor = NULL; wnd_class.hbrBackground = 0; wnd_class.lpszMenuName = NULL; wnd_class.lpszClassName = window_class_name; wnd_class.hIconSm = NULL; if(RegisterClassExA(\u0026amp;wnd_class) == 0) { DWORD win32_error_val = GetLastError(); printf(\u0026#34;ERROR: RegisterClassA() failed to register window class - win32 error code: %ld\\n\u0026#34;, win32_error_val); return 1; } HWND window_handle = CreateWindowExA (0, window_class_name, window_name, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, window_width, window_height, NULL, NULL, hInstance, NULL); if(window_handle == NULL) { DWORD win32_error_val = GetLastError(); printf(\u0026#34;ERROR: CreateWindowExA() failed to create window - win32 error code: %ld\\n\u0026#34;, win32_error_val); return 1; } HDC window_DC = GetDC(window_handle); if(window_DC == NULL) { printf(\u0026#34;ERROR: GetDC() failed to get DC for window\\n\u0026#34;); return 1; } /* @! */ /* @@ creating the real Gl context */ #define PI_ATTRIB_LIST_LENGTH 19 int pi_attrib_list[PI_ATTRIB_LIST_LENGTH]; pi_attrib_list[0] = WGL_DRAW_TO_WINDOW_ARB; pi_attrib_list[1] = TRUE; pi_attrib_list[2] = WGL_SUPPORT_OPENGL_ARB; pi_attrib_list[3] = TRUE; pi_attrib_list[4] = WGL_DOUBLE_BUFFER_ARB; pi_attrib_list[5] = TRUE; pi_attrib_list[6] = WGL_PIXEL_TYPE_ARB; pi_attrib_list[7] = WGL_TYPE_RGBA_ARB; pi_attrib_list[8] = WGL_ACCELERATION_ARB; pi_attrib_list[9] = WGL_FULL_ACCELERATION_ARB; pi_attrib_list[10] = WGL_COLOR_BITS_ARB; pi_attrib_list[11] = 32; pi_attrib_list[12] = WGL_ALPHA_BITS_ARB; pi_attrib_list[13] = 8; pi_attrib_list[14] = WGL_DEPTH_BITS_ARB; pi_attrib_list[15] = 24; pi_attrib_list[16] = WGL_STENCIL_BITS_ARB; pi_attrib_list[17] = 8; pi_attrib_list[18] = 0; /* look into WGL_SAMPLE_BUFFERS_ARB for MSAA */ int pixel_format_id; UINT num_formats; if(wglChoosePixelFormatARB(window_DC, pi_attrib_list, NULL, 1, \u0026amp;pixel_format_id, \u0026amp;num_formats) != TRUE) { DWORD win32_error_val = GetLastError(); printf(\u0026#34;ERROR: failed to get pixel format with wglChoosePixelFormatARB() - win32 (or WGL_ARB_pixel_format extension) error code: %ld\\n\u0026#34;, win32_error_val); return 1; } if(num_formats == 0) { printf(\u0026#34;ERROR: no pixel formats found as queried with wglChoosePixelFormatARB()\\n\u0026#34;); return 1; } PIXELFORMATDESCRIPTOR pixel_fd; if(DescribePixelFormat(window_DC, pixel_format_id, sizeof(PIXELFORMATDESCRIPTOR), \u0026amp;pixel_fd) == 0) { DWORD win32_error_val = GetLastError(); printf(\u0026#34;ERROR: DescribePixelFormat() failed - win32 error code: %ld\\n\u0026#34;, win32_error_val); return 1; } if(SetPixelFormat(window_DC, pixel_format_id, \u0026amp;pixel_fd) != TRUE) { DWORD win32_error_val = GetLastError(); printf(\u0026#34;ERROR: failed to set pixel format with SetPixelFormat() - win32 error code: %ld\\n\u0026#34;, win32_error_val); return 1; } #define ATTRIB_LIST_LENGTH 7 int attrib_list[ATTRIB_LIST_LENGTH]; attrib_list[0] = WGL_CONTEXT_MAJOR_VERSION_ARB; attrib_list[1] = 4; attrib_list[2] = WGL_CONTEXT_MINOR_VERSION_ARB; attrib_list[3] = 6; attrib_list[4] = WGL_CONTEXT_PROFILE_MASK_ARB; attrib_list[5] = WGL_CONTEXT_CORE_PROFILE_BIT_ARB; attrib_list[6] = 0; HGLRC wgl_context = wglCreateContextAttribsARB(window_DC, 0, attrib_list); if(wgl_context == NULL) { DWORD win32_error_val = GetLastError(); printf(\u0026#34;ERROR: failed to create WGL (GL) context - win32 (or WGL_ARB_create_context/WGL_ARB_create_context_profile extension) error code: %ld\\n\u0026#34;, win32_error_val); return 1; } /* @! */ /* @@ cleanup of dummygl stuff */ if(wglMakeCurrent(dummygl_DC, NULL) != TRUE) { /* making dummy GL context not current */ printf(\u0026#34;ERROR: wglMakeCurrent() failed to make context NOT current\\n\u0026#34;); return 1; } if(wglDeleteContext(dummygl_context) != TRUE) { /* deleting dummy GL context */ printf(\u0026#34;ERROR: wglDeleteContext() failed to delete the dummy GL context\\n\u0026#34;); return 1; } if(DeleteDC(dummygl_DC) == 0) { /* deleting dummy GL device context */ printf(\u0026#34;ERROR: DeleteDC() failed to delete the dummy GL Device Context\\n\u0026#34;); return 1; } if(DestroyWindow(dummygl_window_handle) == 0) { /* destroying dummy GL window */ printf(\u0026#34;ERROR: DestroyWindow() failed to destroy the dummy GL window\\n\u0026#34;); return 1; } if(UnregisterClassA(dummygl_window_class_name, hInstance) == 0) { /* unregistering dummy GL window class */ printf(\u0026#34;ERROR: UnregisterClassA() failed to unregister the dummy GL window class: %s\\n\u0026#34;, dummygl_window_class_name); return 1; } /* @! */ /* @@ now we make the real context current, the WGL context */ if(wglMakeCurrent(window_DC, wgl_context) != TRUE) { printf(\u0026#34;ERROR: wglMakeCurrent() failed to make context current\\n\u0026#34;); } /* @! */ Creating the window is the same as before, except that this is the real window so you want to set properties knowing that it\u0026rsquo;s the one that will be visible. After window creation, we grab the window DC again which will be used in creation of the real context.\nNow, we can create the new GL context which is where our new extensions come into play.\nWe need to specify an attribute list: pi_attrib_list, which we set to have a number of important properties. This attribute list will be used in creation of our new pixel format with the wglChoosePixelFormatARB() function, and is the main reason why we needed this extension function in the first place. With this attribute list we can also choose double buffering and/or MSAA, which was not possible with the legacy context.\nThen, we use DescribePixelFormat() to get a pixel descriptor, and then pass that to SetPixelFormat() so that we can finally set the pixel format for this window.\nWe then create the context with wglCreateContextAttribsARB() which we loaded prior, passing in an attribute list to specify the version of OpenGL we will be using and some other things.\nOnce we are done that, we cleanup the old dummy window and dummy context as we no longer need it. Right after that, we finally make the new GL context current with wglMakeCurrent() and now we have a modern OpenGL context created current to our thread!\nTechnically we\u0026rsquo;re done at this point as we have a modern GL context now, but there\u0026rsquo;s still more to go over.\nLoading WGL Extension Procedures (Again) # Now that we have a new context, we should reload any procedures that we had in the previous context. This is a matter of good practice, as according to the MSDN documentation:\nThe OpenGL library supports multiple implementations of its functions. Extension functions supported in one rendering context are not necessarily available in a separate rendering context. Thus, for a given rendering context in an application, use the function addresses returned by the wglGetProcAddress function only\nSo it\u0026rsquo;s best to reload any extension procedures that we need.\n/* @@ loading WGL extension procedures (again) for the real Gl context. */ /* We reload the string extension procedure (as it\u0026#39;s the only one we will reuse), and then load the rest of the WGL and GL procedures now that we have the real context. According to the MSDN docs for wglGetProcAddress(): \u0026#34;Extension functions supported in one rendering context are not necessarily available in a separate rendering context. Thus, for a given rendering context in an application, use the function addresses returned by the wglGetProcAddress function only.\u0026#34;. In practice, we may not need to do this, but as a matter of *good* practice we should. */ wglGetExtensionsStringARB = NULL; wglGetExtensionsStringARB = (PFNWGLGETEXTENSIONSSTRINGARBPROC) Load_WGL_Proc(\u0026#34;wglGetExtensionsStringARB\u0026#34;); if(wglGetExtensionsStringARB == NULL) { printf(\u0026#34;ERROR: failed to load wglGetExtensionsStringARB()\\n\u0026#34;); return 1; } extensions_string = wglGetExtensionsStringARB(window_DC); /* grabbing the extensions again */ PFNWGLSWAPINTERVALEXTPROC wglSwapIntervalEXT = NULL; PFNWGLGETSWAPINTERVALEXTPROC wglGetSwapIntervalEXT = NULL; /* it\u0026#39;s not necessary to require that these extensions be present, we could leave it as an optional feature, but for our program, we will require them. */ if(Check_Extension_Available(extensions_string, \u0026#34;WGL_EXT_swap_control\u0026#34;) != 1) { printf(\u0026#34;ERROR: WGL_EXT_swap_control extension not found\\n\u0026#34;); return 1; } if(Check_Extension_Available(extensions_string, \u0026#34;WGL_EXT_swap_control_tear\u0026#34;) != 1) { printf(\u0026#34;ERROR: WGL_EXT_swap_control_tear extension not found\\n\u0026#34;); return 1; } wglSwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC) Load_WGL_Proc(\u0026#34;wglSwapIntervalEXT\u0026#34;); wglGetSwapIntervalEXT = (PFNWGLGETSWAPINTERVALEXTPROC) Load_WGL_Proc(\u0026#34;wglGetSwapIntervalEXT\u0026#34;); if(wglSwapIntervalEXT == NULL) { printf(\u0026#34;ERROR: failed to load proc: \\\u0026#34;wglSwapIntervalEXT\\\u0026#34;\\n\u0026#34;); return 1; } if(wglGetSwapIntervalEXT == NULL) { printf(\u0026#34;ERROR: failed to load proc: \\\u0026#34;wglGetSwapIntervalEXT\\\u0026#34;\\n\u0026#34;); return 1; } /* @! */ In this case, we also load wglSwapIntervalEXT() which is used to set v-sync.\nLoading GL procedures # Let\u0026rsquo;s also load some GL procedures that we might need for a typical short OpenGL \u0026ldquo;hello triangle\u0026rdquo; application:\n/* @@ Loading OpenGL procedures (we need the \u0026#34;glext.h\u0026#34; header for the function typedefs and declarations). */ PFNGLGETSTRINGIPROC glGetStringi = NULL; PFNGLGENBUFFERSPROC glGenBuffers = NULL; PFNGLBINDBUFFERPROC glBindBuffer = NULL; PFNGLBUFFERDATAPROC glBufferData = NULL; PFNGLCREATESHADERPROC glCreateShader = NULL; PFNGLSHADERSOURCEPROC glShaderSource = NULL; PFNGLCOMPILESHADERPROC glCompileShader = NULL; PFNGLCREATEPROGRAMPROC glCreateProgram = NULL; PFNGLATTACHSHADERPROC glAttachShader = NULL; PFNGLLINKPROGRAMPROC glLinkProgram = NULL; PFNGLDELETESHADERPROC glDeleteShader = NULL; PFNGLUSEPROGRAMPROC glUseProgram = NULL; PFNGLVERTEXATTRIBPOINTERPROC glVertexAttribPointer = NULL; PFNGLENABLEVERTEXATTRIBARRAYPROC glEnableVertexAttribArray = NULL; PFNGLGENVERTEXARRAYSPROC glGenVertexArrays = NULL; PFNGLBINDVERTEXARRAYPROC glBindVertexArray = NULL; glGetStringi = (PFNGLGETSTRINGIPROC)Load_WGL_Proc((const char *)\u0026#34;glGetStringi\u0026#34;); glGenBuffers = (PFNGLGENBUFFERSPROC)Load_WGL_Proc((const char *)\u0026#34;glGenBuffers\u0026#34;); glBindBuffer = (PFNGLBINDBUFFERPROC)Load_WGL_Proc((const char *)\u0026#34;glBindBuffer\u0026#34;); glBufferData = (PFNGLBUFFERDATAPROC)Load_WGL_Proc((const char *)\u0026#34;glBufferData\u0026#34;); glCreateShader = (PFNGLCREATESHADERPROC)Load_WGL_Proc((const char *)\u0026#34;glCreateShader\u0026#34;); glShaderSource = (PFNGLSHADERSOURCEPROC)Load_WGL_Proc((const char *)\u0026#34;glShaderSource\u0026#34;); glCompileShader = (PFNGLCOMPILESHADERPROC)Load_WGL_Proc((const char *)\u0026#34;glCompileShader\u0026#34;); glCreateProgram = (PFNGLCREATEPROGRAMPROC)Load_WGL_Proc((const char *)\u0026#34;glCreateProgram\u0026#34;); glAttachShader = (PFNGLATTACHSHADERPROC)Load_WGL_Proc((const char *)\u0026#34;glAttachShader\u0026#34;); glLinkProgram = (PFNGLLINKPROGRAMPROC)Load_WGL_Proc((const char *)\u0026#34;glLinkProgram\u0026#34;); glDeleteShader = (PFNGLDELETESHADERPROC)Load_WGL_Proc((const char *)\u0026#34;glDeleteShader\u0026#34;); glUseProgram = (PFNGLUSEPROGRAMPROC)Load_WGL_Proc((const char *)\u0026#34;glUseProgram\u0026#34;); glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)Load_WGL_Proc((const char *)\u0026#34;glVertexAttribPointer\u0026#34;); glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)Load_WGL_Proc((const char *)\u0026#34;glEnableVertexAttribArray\u0026#34;); glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC)Load_WGL_Proc((const char *)\u0026#34;glGenVertexArrays\u0026#34;); glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC)Load_WGL_Proc((const char *)\u0026#34;glBindVertexArray\u0026#34;); if(glGetStringi == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glGetStringi\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glGenBuffers == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glGenBuffers\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glBindBuffer == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glBindBuffer\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glBufferData == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glBufferData\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glCreateShader == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glCreateShader\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glShaderSource == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glShaderSource\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glCompileShader == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glCompileShader\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glCreateProgram == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glCreateProgram\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glAttachShader == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glAttachShader\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glLinkProgram == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glLinkProgram\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glDeleteShader == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glDeleteShader\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glUseProgram == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glUseProgram\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glVertexAttribPointer == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glVertexAttribPointer\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glEnableVertexAttribArray == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glEnableVertexAttribArray\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glGenVertexArrays == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glGenVertexArrays\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } if(glBindVertexArray == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glBindVertexArray\\\u0026#34; function pointer NULL\\n\u0026#34;); return 1; } /* @! */ This code makes use of the Load_WGL_Proc() wrapper function that we wrote beforehand.\nSetting up Hello Triangle # Once we have the GL functions loaded, we can actually start doing some OpenGL rendering. Here is some code for creating a basic \u0026ldquo;hello triangle\u0026rdquo; that we will render:\n/* @@ setting up rendering of hello triangle */ #define VERT_SIZE 9 GLfloat vertices[VERT_SIZE]; vertices[0] = -0.5f; vertices[1] = -0.5f; vertices[2] = 0.0f; vertices[3] = 0.5f; vertices[4] = -0.5f; vertices[5] = 0.0f; vertices[6] = 0.0f; vertices[7] = 0.5f; vertices[8] = 0.0f; /* @TODO: use the new glCreateBuffers() and glNamedBufferStorage() and see if that works! */ const char * vert_shader_source = \u0026#34;#version 460 core\\n\u0026#34; \u0026#34;layout (location = 0) in vec3 vpos;\\n\u0026#34; \u0026#34;void main()\\n\u0026#34; \u0026#34;{\\n\u0026#34; \u0026#34;gl_Position = vec4(vpos.x, vpos.y, vpos.z, 1.0);\\n\u0026#34; \u0026#34;}\\n\\0\u0026#34;; const char * frag_shader_source = \u0026#34;#version 460 core\\n\u0026#34; \u0026#34;out vec4 frag_color;\\n\u0026#34; \u0026#34;void main()\\n\u0026#34; \u0026#34;{\\n\u0026#34; \u0026#34;frag_color = vec4(0.1f, 0.7f, 0.5f, 1.0f);\\n\u0026#34; \u0026#34;}\\n\\0\u0026#34;; GLuint vert_shader; GLuint frag_shader; GLuint shader_program; vert_shader = glCreateShader(GL_VERTEX_SHADER); frag_shader = glCreateShader(GL_FRAGMENT_SHADER); shader_program = glCreateProgram(); glShaderSource(vert_shader, 1, \u0026amp;vert_shader_source, NULL); glShaderSource(frag_shader, 1, \u0026amp;frag_shader_source, NULL); glCompileShader(vert_shader); glCompileShader(frag_shader); glAttachShader(shader_program, vert_shader); glAttachShader(shader_program, frag_shader); glLinkProgram(shader_program); glDeleteShader(vert_shader); glDeleteShader(frag_shader); GLuint vao; GLuint vbo; glGenVertexArrays(1, \u0026amp;vao); glGenBuffers(1, \u0026amp;vbo); glBindVertexArray(vao); glBindBuffer(GL_ARRAY_BUFFER, vbo); glBufferData(GL_ARRAY_BUFFER, VERT_SIZE * sizeof(GLfloat), (const void *)vertices, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (void *)0); glEnableVertexAttribArray(0); /* @! */ Once this is done, we\u0026rsquo;ll be able to render a simple triangle to the screen in our main loop, which we\u0026rsquo;ll talk about next.\nBefore we do that, we should set the GL viewport with glViewport() and also show our window with ShowWindow() so that it is visible:\n/* @@ setting glViewport() */ RECT window_size; GetClientRect(window_handle, \u0026amp;window_size); glViewport(0, 0, window_size.right - window_size.left, window_size.bottom - window_size.top); /* @! */ /* @@ Finally at the end, we show the window, similar to XMapRaised() or XMapWindow() for X11 */ ShowWindow(window_handle, SW_SHOWNORMAL); /* @! */ The window is technically visible at this point, but the application will return almost as soon as it starts so we might not see it. To see our window (and also render the triangle), we need to write the main loop.\nMain Event/Message Loop \u0026amp; Cleanup # Now we need to write the main event or message loop which will process window messages and also do rendering.\nThe code is as follows:\n/* @@ main loop */ MSG msg; while(program_running) {\t/* @@ flush/process/get messages */ while(PeekMessageA(\u0026amp;msg, NULL, 0, 0, PM_REMOVE) != 0) { if(LOWORD(msg.message) == WM_QUIT) { program_running = 0; break; } TranslateMessage(\u0026amp;msg);\tDispatchMessage(\u0026amp;msg); } /* @! */ /* @@ rendering */ glClearColor(0.1f, 0.15f, 0.19f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(shader_program); glBindVertexArray(vao); glDrawArrays(GL_TRIANGLES, 0, 3); /* @! */ /* @@ swapping and synching */ wglSwapLayerBuffers(window_DC, WGL_SWAP_MAIN_PLANE); glFinish(); /* blocks until all previous GL commands finish, including the buffer swap. */ /* @! */ } /* @! */ There\u0026rsquo;s not much that\u0026rsquo;s different here than on other platforms, besides of course the PeekMessageA() message loop. Basically, we get all the messages of the queue and process them one-by-one. DispatchMessageA() is the function that actually sends our message to the window procedure WindowProc(). Keep in mind that not all messages are sent with DispatchMessageA(), many are just sent directly to the window procedure.\nLastly, once the main loop exits, we need to cleanup everything and return:\n/* @@ Cleanup and Exit */ if(wglMakeCurrent(window_DC, NULL) != TRUE) { /* making WGL context not current */ printf(\u0026#34;ERROR: wglMakeCurrent() failed to make context NOT current\\n\u0026#34;); } if(wglDeleteContext(wgl_context) != TRUE) { /* deleting WGL context */ printf(\u0026#34;ERROR: wglDeleteContext() failed to delete WGL context\\n\u0026#34;); } if(DeleteDC(window_DC) == 0) { /* deleting window device context */ printf(\u0026#34;ERROR: DeleteDC() failed to delete window Device Context\\n\u0026#34;); } if(DestroyWindow(window_handle) == 0) { DWORD win32_error_val = GetLastError(); printf(\u0026#34;ERROR: failed to destroy window with DestroyWindow() - win32 error code: %ld\\n\u0026#34;, win32_error_val); } if(UnregisterClassA(window_class_name, hInstance) == 0) { /* unregistering window class */ printf(\u0026#34;ERROR: UnregisterClassA() failed to unregister window class: %s\\n\u0026#34;, window_class_name); } return 0; /* @! */ And that\u0026rsquo;s it! Once you have this working, you\u0026rsquo;re on your way to program native OpenGL applications on windows!\nSource Code # As promised, the full source code (and more) is provided in my github repo. Feel free to use it as you wish. There\u0026rsquo;s some minor differences, namely there\u0026rsquo;s a section of code that turns on fullscreen which I left out in the tutorial here as I viewed that to be windows-specific and not really related to OpenGL.\nReferences # MSDN tutorial for using MSVC on the command line: https://learn.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170 Build Tools for Visual Studio: https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2022 Khronos OpenGL registry: https://registry.khronos.org/OpenGL/index_gl.php Khronos Opengl Context Creation Tutorial: https://www.khronos.org/opengl/wiki/Tutorial:OpenGL_3.0_Context_Creation(GLX) Khronos tutorial on loading OpenGL functions: (https://www.khronos.org/opengl/wiki/Load_OpenGL_Functions)[https://www.khronos.org/opengl/wiki/Load_OpenGL_Functions] WINE list of windows messages: https://gitlab.winehq.org/wine/wine/-/wikis/Wine-Developer\u0026rsquo;s-Guide/List-of-Windows-Messages WINE implementation of default window procedure: https://gitlab.winehq.org/wine/wine/-/blob/master/dlls/win32u/defwnd.c#L2388 The amazing and classic learnOpenGL tutorial: https://learnopengl.com/ ","date":"2 May 2025","externalUrl":null,"permalink":"/posts/win32_window_opengl/","section":"Posts","summary":"","title":"Creating a win32 Window and OpenGL Context on Windows From Scratch","type":"posts"},{"content":"Let me start off by saying that it\u0026rsquo;s not that difficult to open a native window with no libraries or other extra help. Sure, it\u0026rsquo;s not as easy as using a library like SDL, but it\u0026rsquo;s also not so complicated that you can\u0026rsquo;t at least understand how it works. Don\u0026rsquo;t get me wrong, I\u0026rsquo;m all for SDL and other similar libraries such as GLFW, but it\u0026rsquo;s certainly a good thing to at least understand how these libraries operate.\nChances are that if you\u0026rsquo;re here, you\u0026rsquo;re already pursuing something plenty difficult enough that manually opening a native window and creating an OpenGL context is not something that deters you anyways, but I still emphasize that it is not difficult to do so. I also consider the proposition that doing this is a \u0026ldquo;waste of time\u0026rdquo; to be absurd, and one that could only come from a place of ignorance, perpetrated by people who lack understanding of how to do it themselves.\nIn fact, this generally negative attitude towards \u0026ldquo;low-level\u0026rdquo; programming among the software people community is the exact reason why documentation is generally scarce on this subject, precisely because everyone just uses a library and thus few people know how to do it manually. It\u0026rsquo;s quite sad that new and curious programmers are discouraged to delve into native programming by so-called \u0026ldquo;senior software engineers\u0026rdquo;, who themselves only issue these warnings out of their own ignorance and incompetence. Either way, it is the sparsity of documentation surrounding this subject that has prompted me to write this tutorial and give a full overview of what is needed to get started.\nFurthermore, an important reason why I am making this tutorial is because the existing ones surrounding this subject are also full of error. I claim to have found some important errors that would set back new developers quite a bit, and I\u0026rsquo;ll go over exactly what these errors are in this tutorial. Still, I\u0026rsquo;m grateful for the tutorials that exist and have referenced them extensively in this post.\nAlright, let\u0026rsquo;s actually get into to it!\nX11 \u0026amp; GLX # To talk about opening a native window on any platform we need to understand what the native windowing system is. In the case of Microsoft Windows, the windowing system is built into the general platform API known as win32. In the case of linux, windowing systems are seperate from the kernel (properly speaking, seperate from linux itself), but the most widely used windowing system across different linux distributions is X11 by far. Wayland is another option, but I won\u0026rsquo;t be touching that.\nX11, or The X Window system is a bitmap display system based on a client-server architecture with a specified protocol called the \u0026ldquo;X Protocol\u0026rdquo;. Applications communicate to the X Sever (which may be on the same device, or across a network) with commands to peform actions.\nProgramming X11 is therefore writing a client application that can communicate with an X11 server, via the X Protocol. Typically, the X sever is on the same device as the client, and in fact we will be counting on that in our OpenGL application as we don\u0026rsquo;t want to consider networked graphics applications.\nIt is within possibility to learn the X Protocol and manually implement it within your client application, but this is beyond what I would consider practical. Rather than that, Xlib is provided for us as a C library that implements the X Protocol so that we can communicate between server and client with an API interface. This is the option I will be going with for this tutorial, but the X protocol is standardized and you absolutely could go look at it for yourself.\nIn order to create and use an OpenGL context, we will need an extension to X11/Xlib called GLX, or the OpenGL extension to the X Window System, which is what allows us to create a framebuffer and use it within an OpenGL context. If we were on windows, we would use win32/WGL. GLX is what allows us to do most of the important work to link our X11 Window and OpenGL context so that we can start doing graphics rendering.\nDocumentation for X11/Xlib and GLX # It\u0026rsquo;s important to be aware of the documentation for the two main APIs involved here, X11/Xlib, and GLX, of which GLX is really just an API extension to Xlib.\nUnfortunately, the documentation for creating a window and GL context with Xlib/GLX is rather spread out all over the place. Further, the documentation that does exist is poor and outdated in some areas, which is part of the motivation for me making this tutorial.\nThe Xlib documentation is found here: https://www.x.org/wiki/ProgrammingDocumentation/ , and the GLX documentation is found within the Khronos OpenGL registry here: https://registry.khronos.org/OpenGL/index_gl.php. Even though GLX is a library extension to Xlib, it is listed in the OpenGL Registry which can be somewhat confusing. Out of all the documentation cited in this post, GLX is easily the worst, so I\u0026rsquo;ll do my best to explain it. You should really grab the documentation for Xlib, GLX, and also the OpenGL core spec as well, which can also be found in the Khronos OpenGL registry.\nGLX 1.4 is the latest version and the one we will be using, but the documentation for it is outdated and flawed in many ways. It appears that the maintainers have given up on updating it since probably the early 2010s. For example, this documentation here: https://registry.khronos.org/OpenGL/extensions/EXT/GLX_EXT_swap_control_tear.txt suggests edits and additions to the GLX 1.4 spec that are not actually present. If you grab the latest spec you won\u0026rsquo;t find these additions or changes anywhere. There are several other examples where these proposed \u0026ldquo;additions\u0026rdquo; are not to be found anywhere with the GLX 1.4 spec found in the Khronos OpenGL registery. It\u0026rsquo;s possible that these extensions were intended for the next version of GLX, so \u0026ldquo;GLX 1.5\u0026rdquo;, but that never came so we are left with somewhat of a mess.\nWhat this really means for us is that we just need to read the extension documentation alongside the GLX 1.4 spec, which is not really that bad.\nStarter Program and Compilation with GCC # I\u0026rsquo;m going to be compiling with GCC and be using C, but you can also follow along in C++ with only a few modificaitions. If you read the Xlib documentation you\u0026rsquo;ll note that most functions are provided as Macros, this is exactly so that either C or C++ can use the macro and get the right function. I just call the functions directly personally.\nAnyways, start with this C code, and name it something like \u0026ldquo;x11_window.c\u0026rdquo;:\n#include \u0026lt;stdio.h\u0026gt;; #define TRUE 1 #define FALSE 0 int main() { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } then, compile with this command:\ngcc x11_window.c -o x11_window run it with:\n./x11_window and you should get \u0026ldquo;Hello World!\u0026rdquo; as output.\nAlso, at the end of the main function add a cleanup section like this:\n#include \u0026lt;stdio.h\u0026gt; #define TRUE 1 #define FALSE 0 int main() { printf(\u0026#34;Hello World!\\n\u0026#34;); CLEANUP_AND_EXIT: return 0; } for now the cleanup section just returns from the main function. We\u0026rsquo;ll be referring back to this cleanup section later.\nSetting up X11 Display # The first task is to open a connection to the X11 Display Server, the X Server. If no server exists on the host machine (or on the network if we specify a device across the network), then this will fail and we will have no way of displaying anything. We NEED an X server to have an X window, so either prompt the user to install/run the X server or something else.\nAnyways, we can open a connection to the X server and get a Display back using the XOpenDisplay() function.\n/* @@ opening connection to X server */ Display* display = NULL; int display_exists = FALSE; int default_screen_id = 0; display = XOpenDisplay(NULL); if(display == NULL) { printf(\u0026#34;ERROR: failed to open X11 display, display name: \\\u0026#34;%s\\\u0026#34;\\n\u0026#34;, XDisplayName(NULL)); goto CLEANUP_AND_EXIT; } else { display_exists = TRUE; default_screen_id = XDefaultScreen(display); } /* @! */ make sure to also have #include \u0026lt;X11/Xlib.h\u0026gt; and also link to X11 with GCC by adding the flag: -lX11.\nThis code snippet opens a connection to the X Server, and if it succeeds, also grabs the screen ID which we will need later. NULL is passed in to XOpenDisplay() which will give us the default display and screen of the device we are on.\nIn the cleanup section, we need to close the display with XCloseDisplay() like this:\n/* @@ cleanup and program exit */ CLEANUP_AND_EXIT: if(display_exists == TRUE) { XCloseDisplay(display); } return 0; /* @! */ And that\u0026rsquo;s it for now.\nSetting up GLX # Before we open an X11 window or do anything else, we should query X to see if GLX is supported. We do that using the glXQueryExtension() function, and we also need to include GLX with: #include \u0026lt;GL/glx.h\u0026gt;. We also need to link to GLX with GCC using: -lGLX.\nThe basic code for setting up GLX is like this:\n/* @@ glx initial setup */ int error_base; int event_base; if(glXQueryExtension(display, \u0026amp;error_base, \u0026amp;event_base) != True) { printf(\u0026#34;ERROR: GLX extension not supported for this X Server\\n\u0026#34;); goto CLEANUP_AND_EXIT; } int glx_major_version; int glx_minor_version; if(glXQueryVersion(display, \u0026amp;glx_major_version, \u0026amp;glx_minor_version) != True) { printf(\u0026#34;ERROR: glXQueryVersion() failed\\n\u0026#34;); goto CLEANUP_AND_EXIT; } if( glx_major_version \u0026lt; 1 || (glx_major_version == 1 \u0026amp;\u0026amp; glx_minor_version \u0026lt; 4) ) { /* The reason why we require GLX 1.4 (or higher, although it\u0026#39;s doubtful a new version will be released) is because the GLX_ARB_create_context/GLX_ARB_create_context_profile extensions (which we need) requires GLX 1.4, and we need this extension in order to create a modern OpenGL context, which is what we are doing. \u0026#34;Modern\u0026#34; is somewhat of an outdated term as GLX 1.4 was released in 2005/2006, so there\u0026#39;s nothing really unportable as we require the user to have hardware that can at least support this \u0026#34;modern\u0026#34; OpenGL. */ printf(\u0026#34;ERROR: GLX version is less than 1.4\\n\u0026#34;); goto CLEANUP_AND_EXIT; } /* @! */ With this code snippet, we query to see if the GLX extension to X11 is available for this X display using glXQueryExtension(). Then, we check which version of GLX is supported and we make sure it is at least 1.4, otherwise we won\u0026rsquo;t be able to create a modern OpenGL context due to the GLX_ARB_create_context_profile extension requiring GLX 1.4, according to the documentation for the extension found here.\nI won\u0026rsquo;t be considering supporting old or legacy OpenGL in this tutorial, as I view that is a niche topic with less practical application.\nChecking for GLX extensions # After having made sure we have GLX 1.4 supported, we then need to check to see what extensions are supported. Some extensions are mandatory for creating a modern OpenGL context, but some are also very useful such as querying for swap control which gives us access to double-buffered vsync swapping. Note that GLX extensions are NOT the same thing as OpenGL or GL extensions, they are mutually exclusive with some exceptions. GLX extensions are properly extensions to GLX itself that gives you greater functionality, one of these extensions is GLX_ARB_create_context_profile which is necessary for a core OpenGL profile.\nTo query for extensions we use the glXQueryExtensionsString() function, which gives us a space-seperated list of extensions that we can check through. It\u0026rsquo;s a good idea to print out this string and check each extension for yourself to see what kinds of things GLX extensions accomplish.\nFor our interests, we only care about two other extensions besides GLX_ARB_create_context_profile, which are GLX_EXT_swap_control and GLX_EXT_swap_control_tear. These two swap control extensions give us normal vsync and adaptive vsync respectively. We don\u0026rsquo;t strictly need them, so you can decide whether they are required for your application or not.\n/* @@ Checking for GLX extensions */ const char* glx_extensions_string = glXQueryExtensionsString(display, default_screen_id); /* @NOTE: GLX_ARB_create_context_profile is absolutely neccessary in order to create a GL context, we cannot proceed without it. Technically, we need only check if GLX_ARB_create_context is supported rather than GLX_ARB_create_context_profile, because the former implies the latter is supported, IF the implementation supports OpenGL 3.2 or later, but we are definitely using a version higher than OpenGL 3.2, version 4 actually. Still, just in case, we explicity check if GLX_ARB_create_context_profile is supported to be as robust as possible. See this documentation for more details: https://registry.khronos.org/OpenGL/extensions/ARB/GLX_ARB_create_context.txt, specifically check the \u0026#34;Dependencies on OpenGL 3.2 and later OpenGL versions\u0026#34; section. */ if(search_str_in_str(glx_extensions_string, \u0026#34;GLX_ARB_create_context_profile\u0026#34;) != TRUE) { printf(\u0026#34;ERROR: \\\u0026#34;GLX_ARB_create_context\\\u0026#34; extension not supported, cannot create GL context!\u0026#34;); goto CLEANUP_AND_EXIT; } /* EXT_swap_control give us the ability to synchronize the swap (v-sync) by an integer amount of frames greater or equal to 0. */ if(search_str_in_str(glx_extensions_string, \u0026#34;GLX_EXT_swap_control\u0026#34;) != TRUE) { printf(\u0026#34;ERROR: \\\u0026#34;GLX_EXT_swap_control\\\u0026#34; extension not supported!\u0026#34;); goto CLEANUP_AND_EXIT; } /* This allows us to use adaptive v-sync for when we miss a swap by specifying negative integer intervals. Adaptive vsync is a generally a good compromise with double-buffering. This extension depends upon the GLX_EXT_swap_control extension to be available/supported. */ if(search_str_in_str(glx_extensions_string, \u0026#34;GLX_EXT_swap_control_tear\u0026#34;) != TRUE) { printf(\u0026#34;ERROR: \\\u0026#34;GLX_EXT_swap_control_tear\\\u0026#34; extension not supported!\u0026#34;); goto CLEANUP_AND_EXIT; } /* @! */ The search_str_in_str() function can be whatever you want, but all it does is find if a string is contained within another string.\nOtherwise, that\u0026rsquo;s basically it for searching for GLX extensions. You can check for any other additional extensions if you like, but we\u0026rsquo;ll be sticking with these three.\nLoading GLX extension procedures # All GLX/GL extensions add functionality in one way or another. Some of them just change how things work, but some of them add new procedures that we have to load at runtime. These are not available at runtime precisely because they are extensions, so depending on the platform, they may or may not be available. Not only that, but the way they are implemented is also different depending on the driver\u0026rsquo;s implementation.\nSupposedly, extensions should function as they are described by the standards, but in reality, there is not universal consistency and sometimes things don\u0026rsquo;t work as expected. This is annoying, but we have to deal with this as graphics programmers and just do our best.\nThe most important extension is the GLX_ARB_create_context_profile extension which gives us the function glXCreateContextAttribsARB(), which is what we need to use to create a modern (core profile) OpenGL context.\nSince glXCreateContextAttribsARB() is an extension procedure, we need to load it with function pointers. But how can we load this function? It turns out, GLX provides us with a function glXGetProcAddress() which allows us to load both GLX extension procedures AND OpenGL (GL) extension procedures. There is also the similar glXGetProcAddressARB() function, which only differs in the \u0026ldquo;ARB\u0026rdquo; suffix. The ARB function is the extension function, as this used to be an extension to GLX but is now integrated into GLX 1.4 as a main function.\n/* @@ loading GLX extension procedures (we need the \u0026#34;glxext.h\u0026#34; header for the function typedefs and declarations). */ PFNGLXCREATECONTEXTATTRIBSARBPROC glXCreateContextAttribsARB = NULL; PFNGLXSWAPINTERVALEXTPROC glXSwapIntervalEXT = NULL; glXCreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glXCreateContextAttribsARB\u0026#34;); glXSwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glXSwapIntervalEXT\u0026#34;); if(glXCreateContextAttribsARB == NULL) { printf(\u0026#34;ERROR: glXCreateContextAttribsARB() function pointer NULL, cannot create GL context!\\n\u0026#34;); goto CLEANUP_AND_EXIT; } if(glXSwapIntervalEXT == NULL) { printf(\u0026#34;ERROR: \\\u0026#34;glXSwapIntervalEXT\\\u0026#34; function pointer NULL\\n\u0026#34;); goto CLEANUP_AND_EXIT; } /* @! */ Along with loading the glXCreateContextAttribsARB() proc, we also load the glXSwapIntervalEXT() proc which allows us to specify a swap interval, giving us the ability to control vsync. Of course, since drivers can override this feature (such as if a user forcibly disables vsync in their control panel for their graphics card), then we can\u0026rsquo;t ensure that it actually works exactly as we request it.\nAlso, make sure you add #include \u0026lt;GL/glxext\u0026gt; which is the extension header for GLX that gives us the extension procedure typedefs and many other useful things. Make sure to include it AFTER the #include \u0026lt;GL/glx.h\u0026gt; otherwise it won\u0026rsquo;t compile.\nSelecting GLX framebuffer config # Now that we have the GLX extension procedure(s) loaded, we need to start thinking about creating a window or framebuffer. We need to create an X11 window that is also compatible with OpenGL rendering, specifically with things like double buffering and other information.\nTo accomplish this, GLX provides something called a framebuffer config or GLXFBConfig, which encapsulates the information we need to create a consistent window/framebuffer between OpenGL and X11.\nOur task is therefore to select a suitable GLXFBConfig, and we can ask for specific settings such as the size of the GL depth buffer, color-bit depth, double-buffering enabled, etc., to get a set of fb configs that match our desired settings:\n/* @@ selecting a GLX FB Config */ /* This fbc attrib array is what specifies the kind of framebuffer we will get, so it\u0026#39;s important to specify everything we need and not leave anything to defaults (unless we don\u0026#39;t care what it is). It\u0026#39;s possible that we specify a configuration that isn\u0026#39;t supported, which means either we need to choose another one that is supported, or we deem the platform to be unsupported by our application. */ int fbc_attribs[] = { GLX_LEVEL, 0, GLX_DOUBLEBUFFER, True, GLX_STEREO, False, GLX_RED_SIZE, 8, GLX_GREEN_SIZE, 8, GLX_BLUE_SIZE, 8, GLX_ALPHA_SIZE, 8, GLX_DEPTH_SIZE, 24, GLX_STENCIL_SIZE, 8, GLX_RENDER_TYPE, GLX_RGBA_BIT, GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT, GLX_X_RENDERABLE, True, GLX_X_VISUAL_TYPE, GLX_TRUE_COLOR, GLX_CONFIG_CAVEAT, GLX_NONE, GLX_TRANSPARENT_TYPE, GLX_NONE, None /* we must put this \u0026#34;None\u0026#34; value here as this array is passed in with no size parameter */ }; int num_fb_configs = 0; GLXFBConfig *fb_configs = glXChooseFBConfig(display, default_screen_id, fbc_attribs, \u0026amp;num_fb_configs); if(fb_configs == NULL || num_fb_configs == 0) { printf(\u0026#34;ERROR: glXChooseFBConfig() failed, or it returned no matching fb configs\\n\u0026#34;); goto CLEANUP_AND_EXIT; } GLXFBConfig best_fb_config = fb_configs[0]; /* for now we are just picking the first FBConfig in the array, but you may want to actually sort through the array and select the one to your liking. */ XFree(fb_configs); /* @! */ The fbc_attribs is an array of pairs, where the first item is a symbolic constant specifying the attribute, and the second item is the value for that attribute.\nThere are many attributes here, I won\u0026rsquo;t go over all of them but some are important which I will detail here:\nGLX_DOUBLEBUFFER is a boolean setting for whether we want to have doublebuffering or not. We set it to True because we want double buffering, which is generally what you want. GLX_RED_SIZE, GLX_GREEN_SIZE, and GLX_BLUE_SIZE set the bit-depth of the red, green, and blue color channels respectively. We want 8-bit color here which is fairly normal, so we set all channels to 8. GLX_DEPTH_SIZE, and GLX_STENCIL_SIZE, are the sizes of the depth buffer and stencil buffer respectively, which we set to 24 and 8, for a total of 32-bits. The other settings are important too, check the GLX/Xlib documentation to see what they mean and to see what the other attribs are.\nOnce we have our attrib array, we need to pass that into the glXChooseFBConfig() function and see if there are any framebuffer configs on the system that matches our requested attributes. The call to glXChooseFBConfig() will return a list of GLXFBConfigs or NULL on failure. Then, we just pick the first GLXFBConfig out of the list and save it for later.\nOnce we are done, we can free the fb_config array with XFree(). If you\u0026rsquo;re wondering why you can\u0026rsquo;t find XFree() in the GLX 1.4 spec, it\u0026rsquo;s because it\u0026rsquo;s not there. XFree() is an Xlib function, which may seem weird as to why we\u0026rsquo;re using an Xlib function for an array returned by a GLX function. But don\u0026rsquo;t forget, GLX is just an extension to Xlib/X11, so it operates on the same basic inherited things that Xlib does, such as memory mangament in this case. Another thing GLX inherits are the Xlib boolean definitions True and False, which are seperate from my own personal TRUE and FALSE.\nCreating an X11 Window and GLX Window # Finally we have what we need to create the Window, the main subject of this tutorial along with an OpenGL context.\nTo create an X11 window, we need to use the framebuffer config from before, and we also need to configure some other X11 attributes. We also need to create a GLX window after, which is basically just a pointer to the X11 window that we have, but it does accomplish some specific things. I\u0026rsquo;ve seen tutorials and people on the internet claim that the GLXWindow type is essentially useless, but this is far from true. More on that later anyways.\nThe code to do all this is:\n/* @@ creating X11 Window and GLX window */ Window parent_window = XDefaultRootWindow(display); Window window; int window_width = 960; int window_height = 540; XVisualInfo* visual_info = glXGetVisualFromFBConfig(display, best_fb_config); /* this GLX function gives us the structure we need to pass into X11 window create function so that our GLX fb config is consistent with the X11 window config. */ if(visual_info == NULL) { printf(\u0026#34;ERROR: glXGetVisualFromFBConfig() failed to get a XVisualInfo struct\\n\u0026#34;); goto CLEANUP_AND_EXIT; } XSetWindowAttributes window_attributes; window_attributes.background_pixmap = None; window_attributes.background_pixel = XWhitePixel(display, default_screen_id); Colormap cmap = XCreateColormap(display, parent_window, visual_info-\u0026gt;visual, AllocNone); window_attributes.colormap = cmap; window = XCreateWindow(display, parent_window, 0, 0, (unsigned int)window_width, (unsigned int)window_height, 0, visual_info-\u0026gt;depth, InputOutput, visual_info-\u0026gt;visual, CWBackPixmap | CWBackPixel | CWColormap, \u0026amp;window_attributes); window_exists = TRUE; XFree(visual_info); /* now we create the GLX window which is basically just a handle to our X11 window, but it does accomplish very important things so we absolutely need it */ /* we need to use the same exact FB config as used to create the context AND to create the X11 window, so we just pass that in here as well. */ GLXWindow glx_window = glXCreateWindow(display, best_fb_config, window, NULL); glx_window_exists = TRUE; /* from now we use glx_window instead of window for any GLX/GL functions. For normal X functions, we continue to use the normal X window. */ /* @! */ Firstly, we need to get a X11 Visual Config from our previous fb config with the glXGetVisualFromFBConfig() function. It may seem pointless that we have the fb config in the first place when we just convert it to an XVisualInfo struct, but the GLX fb config is necessary for the GLX window, and especially for creating an OpenGL context.\nThen, we need to fill out a XSetWindowAttributes struct which contains some basic properties. I\u0026rsquo;ve only set some basic stuff here like making the window white by default, and getting rid of a backgound pixmap which we don\u0026rsquo;t need.\nWe also need a colormap which can be created by a call to XCreateColormap(). I just use the default colormap which is just taken from the parent window. We also need to pass in the visual attribute from the visual_info struct we created from the GLX fb config.\nWith those set, we can pass those into the XCreateWindow() function and finally get our window. We also pass in other settings, like the window width and height. Once we have the window we can free the visual_info struct with XFree().\nAlong with the X window, we also need to create a GLX window which is very simple and only requires a call to glXCreateWindow(), and we need to pass in our GLX fb config which we created earlier, as well as the X window we just created.\nFrom then on, any GLX functions should only use the glx_window variable instead of the X window variable. Use of the latter instead of the former is incorrect, but that is what is commonly seen in many tutorials such as these. Later, I\u0026rsquo;ll go into depth as to why this is necessary. For Xlib functions, use the X window rather than the GLX window.\nAlso, since we created the X window and GLX window, we should clean them up in the cleanup section which will now look like this:\n/* @@ cleanup and program exit */ CLEANUP_AND_EXIT: if(glx_window_exists == TRUE) { glXDestroyWindow(display, glx_window); } if(window_exists == TRUE) { XDestroyWindow(display, window); } if(display_exists == TRUE) { XCloseDisplay(display); } return 0; /* @! */ If you compile the code, the window won\u0026rsquo;t be visible yet because we haven\u0026rsquo;t made the neccessary call to XMapRaised(display, window) which will display our window and raise it to the top. Even doing this won\u0026rsquo;t work because the X server hasn\u0026rsquo;t synced it\u0026rsquo;s request, so we need to do that with the call: XSync(display, False), but even then you won\u0026rsquo;t see the window just yet. The window will close as soon as it opens, so we need to add a sleep() call or something like that to see the window.\nYou could do this if you want to see the window and make sure that it is working, but delete that code for later because we\u0026rsquo;ll handle this in a different way.\nCreating a GLX Context (OpenGL context) and making it current # Now we can create an OpenGL context, and we do this with GLX. If it\u0026rsquo;s confusing as to why an OpenGL context is created with GLX rather than OpenGL itself, that\u0026rsquo;s because OpenGL doesn\u0026rsquo;t \u0026ldquo;exist\u0026rdquo; at this point without a context, so something that doesn\u0026rsquo;t exist cannot create itself. Sure, we can include the GL headers, but the actual context state has not been created yet. Furthermore, much about the context or context state is implementation or platform dependent, so it must be created at runtime, hence the need to create a GL context.\nCreating a modern OpenGL context or core profile context is only supported as a (GLX) extension, specifically, the GLX_ARB_create_context_profile we queried for earlier is needed to do so. The Windows equivalent for this is WGL_ARB_create_context_profile.\nThe GLX_ARB_create_context_profile gives us the extension procedure glXCreateContextAttribsARB() which is what we need to use for a modern or core profile OpenGL. GLX also provides the functions glXCreateNewContext() and glXCreateContext(), but these functions are for OLD pre-modern OpenGL, so we don\u0026rsquo;t want to use them.\nTo create the context, we use the glXCreateContextAttribsARB() function as so:\n/* @@ Creating GLX (GL) context, and making context current. */ int context_attribs[] = { /* @@ with GLX_CONTEXT_MAJOR_VERSION_ARB and GLX_CONTEXT_MAJOR_MINOR_VERSION, the context creation function may actually give us a higher version as long as it is backwards compatible, so we need to query the real OpenGL version with glGet. If we ask for 4.6, it\u0026#39;s unlikely we\u0026#39;ll get a higher version as they probably won\u0026#39;t update OpenGL further. */ GLX_CONTEXT_MAJOR_VERSION_ARB, 4, GLX_CONTEXT_MINOR_VERSION_ARB, 6, /* @! */ GLX_CONTEXT_PROFILE_MASK_ARB, GLX_CONTEXT_CORE_PROFILE_BIT_ARB,\tGLX_CONTEXT_FLAGS_ARB, GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB, /* @@ Forward compatible bit is set so that we avoid deprecated functions. This is optional and won\u0026#39;t really change anything since OpenGL isn\u0026#39;t going to change. */ None }; GLXContext glx_context = glXCreateContextAttribsARB(display, best_fb_config, NULL, True, context_attribs); if(glx_context == NULL) { printf(\u0026#34;ERROR: failed to create glx context with glXCreateContextAttribsARB()\\n\u0026#34;); goto CLEANUP_AND_EXIT; } else { glx_context_exists = TRUE; } if(glXIsDirect(display, glx_context) != True) { printf(\u0026#34;ERROR: OpenGL Context was NOT created in direct mode (DRI). It is not supported to run a networked X server setup with the client and server not on the same device. Otherwise, some other error occured.\\n\u0026#34;); goto CLEANUP_AND_EXIT; } if(glXMakeCurrent(display, glx_window, glx_context) != True) { printf(\u0026#34;ERROR: failed to make context current\\n\u0026#34;);\tgoto CLEANUP_AND_EXIT; } else { glx_context_current = TRUE; } /* @! */ First, we fill in an array of attribs context_attribs, which mostly just sets the OpenGL profile major and minor version. Then we pass that, along with our fb_config and some other variables into glXCreateContextAttribsARB(). The NULL is passed in because we don\u0026rsquo;t want to use any shared contexts (we only want one context for this application), and the True is passed in to indicate that we want a Direct Rendering context which is very imporant, we need that if we want any chance of having decent performance.\nNext, we check to make sure using glXIsDirect() that our context is indeed direct, otherwise we exit with failure. Reasons for failing include that the display is not a local X server, or that there are other contexts on the system taking up the max amount of direct contexts supported.\nFinally, we make the context current by a call to glXMakeCurrent() passing in our context, GLX window, and display. This will not work properly with a normal X window, you need to create and use a GLX window.\nLastly, we need to add this to our cleanup section:\n/* @@ cleanup and program exit */ CLEANUP_AND_EXIT: if(glx_context_current == TRUE) { /* This function releases the current context when called with appropriate parameters, we have to first make the context not current or released/unbound to be able to destroy it properly */ glXMakeContextCurrent(display, None, None, NULL); } if(glx_context_exists == TRUE) { glXDestroyContext(display, glx_context); } if(glx_window_exists == TRUE) { glXDestroyWindow(display, glx_window); } if(window_exists == TRUE) { XDestroyWindow(display, window); } if(display_exists == TRUE) { XCloseDisplay(display); } return 0; /* @! */ We just added here to make the context uncurrent and then destroy it.\nAt this point we are technically done, but there are still a couple of other things.\nLoading OpenGL procedures # To use many of the OpenGL procedures, they need to be loaded at runtime. We load GL procedures just like GLX procedures, and there is also a similar extension header to include that is \u0026lt;GL/glext.h\u0026gt;, but we also need to include the headers for OpenGL itself which is \u0026lt;GL/gl.h\u0026gt;, and we also need to link to GL with -lGL in GCC.\nOnce that is done, we can load GL procedures with the following code. I haven\u0026rsquo;t loaded every function, but these are a couple of functions that we\u0026rsquo;ll be using for the rest of the tutorial along with some others:\n/* @@ loading OpenGL procedures (we need the \u0026#34;glext.h\u0026#34; header for the function typedefs and declarations, \u0026#34;glext.h\u0026#34; and \u0026#34;glxext.h\u0026#34; are NOT the same, they are spelled very similar but the former is for OpenGL and the latter is for GLX). */ PFNGLGETSTRINGIPROC glGetStringi = NULL; PFNGLGENBUFFERSPROC glGenBuffers = NULL; PFNGLBINDBUFFERPROC glBindBuffer = NULL; PFNGLBUFFERDATAPROC glBufferData = NULL; PFNGLCREATESHADERPROC glCreateShader = NULL; PFNGLSHADERSOURCEPROC glShaderSource = NULL; PFNGLCOMPILESHADERPROC glCompileShader = NULL; PFNGLCREATEPROGRAMPROC glCreateProgram = NULL; PFNGLATTACHSHADERPROC glAttachShader = NULL; PFNGLLINKPROGRAMPROC glLinkProgram = NULL; PFNGLDELETESHADERPROC glDeleteShader = NULL; PFNGLUSEPROGRAMPROC glUseProgram = NULL; PFNGLVERTEXATTRIBPOINTERPROC glVertexAttribPointer = NULL; PFNGLENABLEVERTEXATTRIBARRAYPROC glEnableVertexAttribArray = NULL; PFNGLGENVERTEXARRAYSPROC glGenVertexArrays = NULL; PFNGLBINDVERTEXARRAYPROC glBindVertexArray = NULL; glGetStringi = (PFNGLGETSTRINGIPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glGetStringi\u0026#34;); glGenBuffers = (PFNGLGENBUFFERSPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glGenBuffers\u0026#34;); glBindBuffer = (PFNGLBINDBUFFERPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glBindBuffer\u0026#34;); glBufferData = (PFNGLBUFFERDATAPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glBufferData\u0026#34;); glCreateShader = (PFNGLCREATESHADERPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glCreateShader\u0026#34;); glShaderSource = (PFNGLSHADERSOURCEPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glShaderSource\u0026#34;); glCompileShader = (PFNGLCOMPILESHADERPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glCompileShader\u0026#34;); glCreateProgram = (PFNGLCREATEPROGRAMPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glCreateProgram\u0026#34;); glAttachShader = (PFNGLATTACHSHADERPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glAttachShader\u0026#34;); glLinkProgram = (PFNGLLINKPROGRAMPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glLinkProgram\u0026#34;); glDeleteShader = (PFNGLDELETESHADERPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glDeleteShader\u0026#34;); glUseProgram = (PFNGLUSEPROGRAMPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glUseProgram\u0026#34;); glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glVertexAttribPointer\u0026#34;); glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glEnableVertexAttribArray\u0026#34;); glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glGenVertexArrays\u0026#34;); glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC)glXGetProcAddress((const GLubyte *)\u0026#34;glBindVertexArray\u0026#34;); /* @! */ Note that some functions like glClear() do not need to be loaded because they are old functions, part of the original OpenGL version. It\u0026rsquo;s only newer procedures (that were once purely extensions, and hence are loaded at runtime) that have to be loaded like this.\nPeople keep complaining about how hard it is to load GL procedures, but it\u0026rsquo;s literally as simple as I have shown you. There are a lot of other caveats, such as checking the GL version and extension to make sure that certain functions are available, but the core idea is fairly simple.\nConsidering that OpenGL will not be updated, and that we\u0026rsquo;ve had 4.6 for almost a decade now, it won\u0026rsquo;t be that difficult to determine which extensions are generally present on most systems. Obviously vendor-specific extension procedures will need to be queried for in a different manner, but the core OpenGL version 4 functions are going to be pretty much available everywhere.\nConfiguring Window/Framebuffer Settings # There are a couple of Window settings we can configure before we get to actual GL rendering. We can set the name of the window, ask X11 to receive certain events (keyboard input), and also turn on vsync:\n/* @@ configuring window parameters */ XStoreName(display, window, \u0026#34;X11 OpenGL Window\u0026#34;); XSelectInput(display, window, KeyPressMask); /* so we can get keyboard inputs in the X11 event loop */ /* even though we checked to see if the extension is present, we should still check again with glXQueryDrawable() to make sure it is there. This is a robust and defensive way of programming that you need to do. */ unsigned int query_val; glXQueryDrawable(display, glx_window, GLX_LATE_SWAPS_TEAR_EXT, \u0026amp;query_val); if(query_val == 1) { /* late swaps is supported, i.e. adaptive v-sync */ glXSwapIntervalEXT(display, glx_window, -1); /* -1 is adaptive v-sync */\tglXQueryDrawable(display, glx_window, GLX_SWAP_INTERVAL_EXT, \u0026amp;query_val); if((int)query_val != -1) { /* even again here we check to make sure it was set properly */ printf(\u0026#34;ERROR: failed to set swapinterval val correctly. \\\u0026#34;-1\\\u0026#34; was requested but we did not get it\\n\u0026#34;); goto CLEANUP_AND_EXIT; } } else { glXSwapIntervalEXT(display, glx_window, 1); /* 1 is normal v-sync */ glXQueryDrawable(display, glx_window, GLX_SWAP_INTERVAL_EXT, \u0026amp;query_val); if(query_val != 1) { printf(\u0026#34;ERROR: failed to set swapinterval val correctly. \\\u0026#34;1\\\u0026#34; was requested but we did not get it\\n\u0026#34;); goto CLEANUP_AND_EXIT; } } glViewport(0, 0, window_width, window_height); /* @! */ First we give our window a name with XStoreName(display, window, \u0026quot;X11 OpenGL Window\u0026quot;), and then we ask it to get keyboard input with XSelectInput() and the KeyPressMask flag.\nThen using glXQueryDrawable(), we double check if what the extensions support is actually there, just to be safe. Depending on what seems to be supported, we either select for late swapping (adaptive vsync) or normal vsync. We set the swap interval with the GLX extension provided procedure glXSwapIntervalEXT().\nLastly, we set the GL viewport with glViewport().\nBasic OpenGL Hello Triangle # As an example, just to prove that this whole tutorial does indeed work - let us setup a basic hello triangle example with OpenGL. I will not write code for this correctly or explain how it works as that is out of the scope of this tutorial. See: LearnOpenGL as an excellent resource for learning how to program OpenGL, of which this example is taken from.\nYou can just copy-paste this code just as a test to see if everything works:\n/* @@ setting up rendering of basic hello triangle */ #define VERT_SIZE 9 GLfloat vertices[VERT_SIZE]; vertices[0] = -0.5f; vertices[1] = -0.5f; vertices[2] = 0.0f; vertices[3] = 0.5f; vertices[4] = -0.5f; vertices[5] = 0.0f; vertices[6] = 0.0f; vertices[7] = 0.5f; vertices[8] = 0.0f; const char * vert_shader_source = \u0026#34;#version 460 core\\n\u0026#34; \u0026#34;layout (location = 0) in vec3 vpos;\\n\u0026#34; \u0026#34;void main()\\n\u0026#34; \u0026#34;{\\n\u0026#34; \u0026#34;gl_Position = vec4(vpos.x, vpos.y, vpos.z, 1.0);\\n\u0026#34; \u0026#34;}\\n\\0\u0026#34;; const char * frag_shader_source = \u0026#34;#version 460 core\\n\u0026#34; \u0026#34;out vec4 frag_color;\\n\u0026#34; \u0026#34;void main()\\n\u0026#34; \u0026#34;{\\n\u0026#34; \u0026#34;frag_color = vec4(0.1f, 0.7f, 0.5f, 1.0f);\\n\u0026#34; \u0026#34;}\\n\\0\u0026#34;; GLuint vert_shader; GLuint frag_shader; GLuint shader_program; vert_shader = glCreateShader(GL_VERTEX_SHADER); frag_shader = glCreateShader(GL_FRAGMENT_SHADER); shader_program = glCreateProgram(); glShaderSource(vert_shader, 1, \u0026amp;vert_shader_source, NULL); glShaderSource(frag_shader, 1, \u0026amp;frag_shader_source, NULL); glCompileShader(vert_shader); glCompileShader(frag_shader); glAttachShader(shader_program, vert_shader); glAttachShader(shader_program, frag_shader); glLinkProgram(shader_program); glDeleteShader(vert_shader); glDeleteShader(frag_shader); GLuint vao; GLuint vbo; glGenVertexArrays(1, \u0026amp;vao); glGenBuffers(1, \u0026amp;vbo); glBindVertexArray(vao); glBindBuffer(GL_ARRAY_BUFFER, vbo); glBufferData(GL_ARRAY_BUFFER, VERT_SIZE * sizeof(GLfloat), (const void *)vertices, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (void *)0); glEnableVertexAttribArray(0); XMapRaised(display, window); /* @! */ The only thing I want to explain is that we make a call to XMapRaised() so that we can finally see the window. This still won\u0026rsquo;t make the window visible, both because the program ends too quickly and also because we need to setup the event loop and actually have X commands flushed to the server.\nX Event Loop \u0026amp; Basic Rendering # The last thing to do is write a basic event loop with rendering the triangle we setup, responding to keyboard events, and swapping buffers.\n/* @@ main loop */ int running = 1; while(running) { glClearColor(0.1f, 0.15f, 0.19f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); /* int num_events = XPending(display); /\\* identical to XEventsQueued(display, QueuedAfterFlush) *\\/ */ XFlush(display); /* rather than calling XFlush() here, we could use the XPending() function instead of XEventsQueued() which will flush the X buffer if needed, I want to ensure that it flushes every frame consistently so that\u0026#39;s why this is done */ int num_events = XEventsQueued(display, QueuedAlready); XEvent event; while(num_events \u0026gt; 0) { XNextEvent(display, \u0026amp;event); if(event.type == KeyPress) { running = 0; } num_events = num_events - 1; } /* @@ rendering */ glUseProgram(shader_program); glBindVertexArray(vao); glDrawArrays(GL_TRIANGLES, 0, 3); /* @! */ /* @@ the order of these last few procedures are critical */ glXSwapBuffers(display, glx_window); glFinish(); /* blocks until all previous GL commands to finish, including the buffer swap. */ /* @! */ } /* @! */ In the loop, we first clear the framebuffer with glClear(). Then, we use XFlush() to flush the X buffer so that we can get access to the latest events, such as keyboard input or window events.\nWe then get the number of events with XEventsQueued(), it\u0026rsquo;s important that we specify QueuedAlready instead of something like QueuedAfterFlush, because we are manually flushing ourselves with XFlush(), so we don\u0026rsquo;t need to use QueuedAfterFlush.\nOnce we have the number of events in the event queue, we simply read off that number of events in a loop with the XNextEvent() function which returns the next event. Be careful when calling the XNextEvent() function, because it will block if there are no events in the queue and wait until another event comes. For some applications this behaviour is desirable, but for a realtime application such as a graphics engine, we definitely do not want that.\nIn our case, we just check if there is keyboard input and kill the program if there is by setting running = 0. Then, we do some basic OpenGL rendering using the setup before.\nThe last two things in the loop is to swap the buffers and then synchronize with glFinish(). glXSwapBuffers() will behave as according to how we controlled the swap interval with glXSwapIntervalEXT(). If we set the swap interval to 0, then it would not try to synchronize to the refresh rate or vertical blank whatsoever.\nCalling glFinish() here is not usually seen, but it is important to understand that the glXSwapBuffers() function does not block or wait for the buffer swap to be complete, all the function does is queue up a buffer swap and lets the driver decide when to actually make the swap (according to vsync rules primarily). If you just call this function without a call to glFinish(), then you might end up queuing subsequent frames early, before the previous frame is visible. Worst-case scenario, you would be possibly a whole frame behind because you\u0026rsquo;re simulation/rendering runs much faster than the refresh rate.\nSynchronization is out of scope for this post, but suffice to say, a call to glFinish() will block until the buffers are swapped. I do not claim to be an expert on this, but for more information, see this blog post.\nAnd that\u0026rsquo;s it! I\u0026rsquo;ll provide the full source code at the end of the page and the GCC options to compile.\nAddendums # There are a couple of extra points I want to clarify or expand upon that were hinted in the post.\nglXGetProcAddress vs glXGetProcAddressARB # So it may be confusing which of these functions to use. For one, the author(s) of the official Khronos API doesn\u0026rsquo;t even seem to know what to use, as according to this link:\nThe function glXGetProcAddress (or glXGetProcAddressARB; it is not entirely clear as to which should be used) retrieves function pointers on X-Windows-based systems.\nSo that\u0026rsquo;s not much help, but I\u0026rsquo;ve done some digging myself on the matter.\nThe glXGetProcAddressARB() function was written against the GLX 1.3 specification, as evidenced by this documentation for the GLX_ARB_get_proc_address extension. However, in the GLX 1.4 spec, the glXGetProcAddressARB() function was promoted to the core glXGetProcAddress() function. You can find this in the \u0026ldquo;GLX Versions\u0026rdquo; section of the GLX 1.4 spec which is at the very end. Therefore, if we use GLX 1.4 (which we are), then we can just use glXGetProcAddress().\nIf you want to support pre GLX 1.4 or legacy OpenGL, consider then using glXGetProcAddressARB().\nGLXWindow vs X Window # So a point I brought up was that we need to create a GLX Window, although some people disagree. This stackoverflow post is incorrect that the GLX window is \u0026ldquo;useless\u0026rdquo;.\nFor one, this GLFW github issue shows a request to use GLFW windows for GLX 1.4 support.\nSecondly, the documentation for the swap control extension mandates that we need to query a GLX window rather than an X window for swap interval properties, otherwise it will not work correctly. Right from these docs:\nThe current swap interval and implementation-dependent max swap interval for a particular drawable can be obtained by calling glXQueryDrawable with the attributes GLX_SWAP_INTERVAL_EXT and GLX_MAX_SWAP_INTERVAL_EXT respectively. The value returned by glXQueryDrawable is undefined if the drawable is not a GLXWindow and these attributes are given.\nAnd in my own testing, I found that using a normal X window instead of a GLX window cause errors just as this spec described. I would get incorrect values for the max swap interval, such as 0, when it returns a much higher number with a GLX window.\nThirdly, if you try to set the swap interval without a GLX window, not only will it crash, but trying to do basic GL rendering won\u0026rsquo;t even work at all.\nThe bottom line is that you can\u0026rsquo;t trust what you see on the internet. I understand that\u0026rsquo;s rich coming from the author here, but I have also provided evidence for my claims.\nSource Code and GCC Options # As promised, the full source code is available here.\nGCC options are as follows:\ngcc x11_window.c -lX11 -lGLX -lGL -o x11_window References # Khronos OpenGL registry (GLX spec is available here): https://registry.khronos.org/OpenGL/index_gl.php Xorg/Xlib Documentation: https://www.x.org/wiki/ProgrammingDocumentation/ Khronos Opengl Context Creation Tutorial: https://www.khronos.org/opengl/wiki/Tutorial:OpenGL_3.0_Context_Creation(GLX) Tutorial by ColleagueRiley on Window/GL context creation: https://github.com/ColleagueRiley/OpenGL-Context-Creation Tutorial by Apoorva Joshi, also on Window/GL context creation: https://apoorvaj.io/creating-a-modern-opengl-context/ Khronos tutorial on loading OpenGL functions: https://www.khronos.org/opengl/wiki/Load_OpenGL_Functions The amazing and classic learnOpenGL tutorial: https://learnopengl.com/ Excellent tutorial that mirrors my own: https://www.tspi.at/2021/06/13/openglcontextx11.html ","date":"5 April 2025","externalUrl":null,"permalink":"/posts/x11_window_opengl/","section":"Posts","summary":"","title":"Creating an X11 Window and OpenGL Context on Linux From Scratch","type":"posts"},{"content":" I\u0026rsquo;ve recently taken a course in group theory, a branch of abstract algebra that studies the mathematical structures known as groups.\nAbstract algebra is a fascinating study in mathematics, as it unifies concepts previously scattered in different areas. Boolean algbera for example is the mathematical structure that underlies working with operations on any kind of binary system. Propositional logic, digital circuit design (logic gates), and even set operations are all forms of boolean algebra. Set operations, propositonal logic, and the design of combinational circuits may seem disparate; but their structure is essentially the same.\nThis is why I have come to love abstract algebra as a discpline. At it\u0026rsquo;s core, it is the formal study of mathematical essence. Two structures may have different substance, but if they function exactly the same up to some kind of isomorphism; then they are the essentially the same.\nGroups, the primary study of group theory, happen to be a type of structure that is encountered very frequently in mathematics. Many other structures such as vector spaces, rings, fields, the real numbers; can all be shown be groups. Therefore, studying groups will reveal properties shared with all of these other structures.\nGroup theory is quite a vast topic, so for this part I\u0026rsquo;m only going to focus on the study of permutations in this post, but this is not without justification. According to Cayley\u0026rsquo;s Theorem, every group is isomorphic to some permutation group. This is another way of saying all groups can be understood in terms of permutations, so it might not be such a bad idea to start there. In the next part we will go over how permutations relate to groups more generally.\nPermutations # A permutation of \\(n\\) numbers is a bijection from \\(\\{1,2,...,n\\}\\) to itself. So it is a surjective function of the form:\n\\[ \\tau : \\{1,2,...,n\\} \\to \\{1,2,...,n\\} \\]As an example, let us define \\(\\tau\\) with \\(n=3\\) to be the following function:\n\\[ \\tau : \\{1,2,3\\} \\to \\{1,2,3\\} \\] Given by the rule: \\[ \\tau (1) = 2, \\tau (2) = 3, \\tau (3) = 1 \\]This means simply that 1 is sent to 2, 2 is sent to 3, and 3 is sent to 1.\nRather than painstakingly write out the function value for each input, we can represent this same exact function \\(\\tau\\) in tabular form as the following:\n\\[ \\begin{bmatrix} 1 \u0026 2 \u0026 3\\\\ 2 \u0026 3 \u0026 1 \\end{bmatrix} \\]This format is known as Cauchy\u0026rsquo;s two-line notation, but we will refer to it as tabular form. All entries are read \u0026ldquo;top-down\u0026rdquo; per column. In any given column, the element of the top row is \u0026ldquo;sent\u0026rdquo; to the element of the bottom row.\nMore generally, we can represent any permutation with the following form:\n\\[ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 \\cdots \u0026 n\\\\ a_1 \u0026 a_2 \u0026 a_3 \u0026 \\cdots \u0026 a_n \\end{bmatrix} \\]And this is read as 1 goes to \\(a_1\\), 2 goes to \\(a_3\\), 3 goes to \\(a_3\\),\u0026hellip;, \\(n\\) goes to \\(a_n\\). Here, \\(n\\) is the number of elements to be permuted, and \\(a_i\\) are the numbers belonging to the set \\(\\{1,2,...,n\\}\\), and it also must be the case that \\(a_i \\neq a_j\\) iff \\(i \\neq j\\). Basically, no \\(a_i\\) can appear more than once. Any kind of table that follows this specific format is a valid permutation.\nNotice also that the order of columns does not matter, as we could freely swap them to our liking without changing the permutation. As a matter of style, we typically like to order the columns by the first/top row with 1,2,3,\u0026hellip; etc.\nEvery finite collection of \\(n\\) objects can be indexed, that is to say, we can label every object with a number from 1 to \\(n\\). Because of this simple and obvious fact, it is sufficient to only study permutations with the set \\(\\{1,2,...,n\\}\\), as every finite set can be put into a one-to-one correspodence with this set.\nCompositions of Permutations # Since permutations are bijective functions from a set to itself, it is possible to compose any number of permutations we like, as long as the permutations are both of \\(n\\) elements.\nThe operation of function composition is given by \\(\\sigma \\circ \\tau (a) = \\sigma (\\tau (a))\\) for two permutations \\(\\tau\\) and \\(\\sigma\\). This means we apply the permutation \\(\\tau\\) first, and then we apply \\(\\sigma\\) second. Composition is read from \u0026ldquo;right-to-left\u0026rdquo; which can be confusing.\nFor example, take two permutations such as these:\n\\[ \\tau = \\begin{bmatrix} 1 \u0026 2 \u0026 3\\\\ 2 \u0026 1 \u0026 3 \\end{bmatrix} , \\sigma = \\begin{bmatrix} 1 \u0026 2 \u0026 3\\\\ 2 \u0026 3 \u0026 1 \\end{bmatrix} \\]Let\u0026rsquo;s see where the number \u0026ldquo;1\u0026rdquo; goes under the composition of \\(\\sigma \\circ \\tau\\): \\(\\tau (1) = 2\\), which implies that \\(\\sigma (\\tau (1)) = \\sigma(2)\\), and \\(\\sigma (2) = 3\\), so that implies that \\(\\sigma \\circ \\tau (1) = \\sigma (\\tau (1)) = 3\\). A similar process can be performed for 2 and 3 to show that: \\(\\sigma (\\tau (2)) = 2\\) and \\(\\sigma (\\tau (3)) = 1\\)\nThere is a much easier way to create compositions of permutations by using the tabular form directly. Using the previous example, Take the first permutation \\(\\tau\\) and superimpose it on top of the second permutation \\(\\sigma\\). (order matters here, don\u0026rsquo;t put \\(\\sigma\\) on the top and \\(\\tau\\) on the bottom). This will create a matrix that has 4 rows, and it should look like this:\n\\[ \\begin{bmatrix} 1 \u0026 2 \u0026 3\\\\ 2 \u0026 1 \u0026 3\\\\ -\u0026-\u0026-\\\\ 1 \u0026 2 \u0026 3\\\\ 2 \u0026 3 \u0026 1 \\end{bmatrix} \\]Then, rearrange the columns of the bottom matrix \\(\\sigma\\) so that the numbers at the top row of \\(\\sigma\\) match the numbers of the bottom row of \\(\\tau\\). In this example, all we need to do is swap column 1 and column 2 of \\(\\sigma\\) just like so:\n\\[ \\begin{bmatrix} 1 \u0026 2 \u0026 3\\\\ 2 \u0026 1 \u0026 3\\\\ -\u0026-\u0026-\\\\ 2 \u0026 1 \u0026 3\\\\ 3 \u0026 2 \u0026 1 \\end{bmatrix} \\]The next step is to simply remove the bottom row of \\(\\tau\\) and remove the top row of \\(\\sigma\\). Basically, remove the middle two rows of the whole matrix and leave the rest:\n\\[ \\begin{bmatrix} 1 \u0026 2 \u0026 3\\\\ 3 \u0026 2 \u0026 1 \\end{bmatrix} \\]But wait, doesn\u0026rsquo;t this just look like another permutation? And in fact it is! Compositions of permutations are themselves permutations! This may seem obvious, but it\u0026rsquo;s an important result that we\u0026rsquo;ll come back to later.\nCompositions of permutations are also associative meaning that for any three permutations \\(\\tau\\), \\(\\sigma\\), and \\(\\rho\\):\n\\[ \\rho \\circ (\\sigma \\circ \\tau) = (\\rho \\circ \\sigma) \\circ \\tau \\]Associativity follows from the fact that function composition in general is always associative, but it is NOT the case that compositions of permutations are always commutative. In general:\n\\[ \\sigma \\circ \\tau \\neq \\tau \\circ \\sigma \\]This inequality doesn\u0026rsquo;t hold for every permutation, as there are some permutations that do commute. We will see some examples of commutative permutations in the next section when we talk about disjoint cycles.\nCycle notation # Another way to represent permutations is with something called cycle notation.\nA cycle is a permutation that takes a collection of distinct numbers in a cycle, leaving all other numbers fixed. For example: 4 -\u0026gt; 2, 2 -\u0026gt; 6, 6 -\u0026gt; 3, 3 -\u0026gt; 4; is a valid cycle because it wraps back around and no number is visited more than once (besides of course the starting number 4, which must be visited twice). The other numbers are left fixed and unchanged.\nWe can represent this example with the following cycle notation:\n\\[ \\begin{pmatrix} 4 \u0026 2 \u0026 6 \u0026 3 \\end{pmatrix} \\]Each number sends you to the next one, and once you reach the end of the list, it wraps back around to the first element. This example is a 4-cycle as there are 4 distinct numbers in the cycle. It also doesn\u0026rsquo;t matter where we start the list as long as we maintain the order, so we could also represent the same 4-cycle as so:\n\\[ \\begin{pmatrix} 2 \u0026 6 \u0026 3 \u0026 4 \\end{pmatrix} \\]and you can verify that this changes nothing, but we tend to prefer to start cycles with the least element as a matter of style. Since any k-cycle is also a permutation, we can also represent it using our tabular form like before. The numbers 1 and 5 are not in this cycle which means that they stay fixed as we mentioned before, so we can write:\n$$ \\begin{pmatrix} 2 \u0026 6 \u0026 3 \u0026 4 \\end{pmatrix} = \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6\\\\ 1 \u0026 6 \u0026 4 \u0026 2 \u0026 5 \u0026 3 \\end{bmatrix} $$But can any permutation be represented by a k-cycle? Let\u0026rsquo;s investigate this to see if it is true by considering the following permutation:\n$$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5\\\\ 2 \u0026 1 \u0026 4 \u0026 5 \u0026 3 \\end{bmatrix} $$Could we represent this as a single cycle? The answer is no! You can try as hard as you want, but there won\u0026rsquo;t be a single k-cycle that can represent this permutation. We can however represent this as a composition of 2 cycles like this:\n$$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5\\\\ 2 \u0026 1 \u0026 4 \u0026 5 \u0026 3 \\end{bmatrix} = \\begin{pmatrix} 1 \u0026 2 \\end{pmatrix} \\circ \\begin{pmatrix} 3 \u0026 4 \u0026 5 \\end{pmatrix} $$Cycle composition follows the exact same rule as permutation composition like we discussed before. Don\u0026rsquo;t forget that a cycle is a permutation, just a different way of representing it.\nRather than using the \\(\\circ\\) notation, we typically just leave it out and only write:\n$$ \\begin{pmatrix} 1 \u0026 2 \\end{pmatrix} \\begin{pmatrix} 3 \u0026 4 \u0026 5 \\end{pmatrix} $$with the understanding that there is an implicit composition between the two cycles, and order also matters as it goes from right-to-left. If we have more than two compositions, we also don\u0026rsquo;t need to use brackets because we know that compositions of permutations are associative.\nIt can be proved that every permutation can be represented either as a single cycle, or as a composition of 2 or more disjoint cycles. It is also the case that the order of compositions doesn\u0026rsquo;t matter with disjoint cycles, so the following equality holds for the previous example:\n$$ \\begin{pmatrix} 1 \u0026 2 \\end{pmatrix} \\begin{pmatrix} 3 \u0026 4 \u0026 5 \\end{pmatrix} = \\begin{pmatrix} 3 \u0026 4 \u0026 5 \\end{pmatrix} \\begin{pmatrix} 1 \u0026 2 \\end{pmatrix} $$The idea is that if a composition of any number of cycles are disjoint, then there are no elements in common. Any element will only be \u0026ldquo;permuted\u0026rdquo; by exactly one of the cycles that happens to contain that element. The other cycles will leave that element fixed, so therefore it doesn\u0026rsquo;t really matter where we place the cycle in the composition.\nTherefore, any composition of disjoint cycles is commutative.\nAlso, if we wanted to, we could for example rewrite the cycle \\(\\begin{pmatrix}3 \u0026 7 \u0026 5\\end{pmatrix}\\) as:\n$$ \\begin{pmatrix} 1 \\end{pmatrix} \\begin{pmatrix} 2 \\end{pmatrix} \\begin{pmatrix} 3 \u0026 7 \u0026 5 \\end{pmatrix} \\begin{pmatrix} 4 \\end{pmatrix} \\begin{pmatrix} 6 \\end{pmatrix} $$but writing all of these extra 1-cycles is redundant, so we usually leave them out.\nIf we want to write the identity permutation (that is, the permutation that takes every number to itself), then we can simply write a cycle with empty brackets \\(\\begin{pmatrix}\\end{pmatrix}\\). This element is special, and so we give it the letter \\(e\\) (not to be confused with euler\u0026rsquo;s number):\n$$ e = \\begin{pmatrix} \\end{pmatrix} = \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 \\cdots \u0026 n\\\\ 1 \u0026 2 \u0026 3 \u0026 \\cdots \u0026 n \\end{bmatrix} $$with the special property that for any permutation \\(\\sigma\\):\n$$ \\sigma \\circ e = e \\circ \\sigma = \\sigma $$ Converting Between Cycle Form and Tabular Form # There is a straightforward way to convert from cycle-form to tabular-form so let\u0026rsquo;s take an example composition of disjoint cycles and see how we can convert it to tabular form:\n$$ \\begin{pmatrix} 1 \u0026 5 \\end{pmatrix} \\begin{pmatrix} 2 \u0026 4 \u0026 6 \\end{pmatrix} \\begin{pmatrix} 7 \u0026 9 \\end{pmatrix} $$Since the largest number here is 9, that means that we are dealing with 9 numbers to be permuted, so create an empty table that has numbers 1 through 9 on the top, and leave the bottom row empty:\n$$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6 \u0026 7 \u0026 8 \u0026 9\\\\ . \u0026 . \u0026 . \u0026 . \u0026 . \u0026 . \u0026 . \u0026 . \u0026 . \\end{bmatrix} $$Our goal here is to \u0026ldquo;fill in the dots\u0026rdquo; and determine what numbers need to go there. For starters, we observe that the numbers 3 and 8 are not in the cycles whatsoever, so we know that they stay fixed:\n$$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6 \u0026 7 \u0026 8 \u0026 9\\\\ . \u0026 . \u0026 3 \u0026 . \u0026 . \u0026 . \u0026 . \u0026 8 \u0026 . \\end{bmatrix} $$Then, we start at the number 1 and see where it maps to. Since the only cycle that 1 belongs to is: \\( \\begin{pmatrix}1 \u0026 5\\end{pmatrix} \\), we know that 1 maps to 5:\n$$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6 \u0026 7 \u0026 8 \u0026 9\\\\ 5 \u0026 . \u0026 3 \u0026 . \u0026 . \u0026 . \u0026 . \u0026 8 \u0026 . \\end{bmatrix} $$Similarly, we can see that 2 maps to 4 because of the cycle \\( \\begin{pmatrix}2 \u0026 4 \u0026 6\\end{pmatrix} \\):\n$$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6 \u0026 7 \u0026 8 \u0026 9\\\\ 5 \u0026 4 \u0026 3 \u0026 . \u0026 . \u0026 . \u0026 . \u0026 8 \u0026 . \\end{bmatrix} $$And if we continue this process we get for the remaining numbers, then we see that we get the following permutation in tabular form:\n$$ \\begin{pmatrix} 1 \u0026 5 \\end{pmatrix} \\begin{pmatrix} 2 \u0026 4 \u0026 6 \\end{pmatrix} \\begin{pmatrix} 7 \u0026 9 \\end{pmatrix} = \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6 \u0026 7 \u0026 8 \u0026 9\\\\ 5 \u0026 4 \u0026 3 \u0026 6 \u0026 1 \u0026 2 \u0026 9 \u0026 8 \u0026 7 \\end{bmatrix} $$and you can verify that this is correct.\nWe also can do the opposite and convert from tabular form to disjoint cycle-form by simply picking numbers and seeing what cycles they belong to. Let\u0026rsquo;s take this same example and convert it back to cycle-form. To start, we pick the number 1 and \u0026ldquo;follow\u0026rdquo; it until we get back to 1. In this case, 1 goes to 5, and 5 goes back to 1, so we write that cycle out:\n$$ \\begin{pmatrix} 1 \u0026 5 \\end{pmatrix} $$Then, we pick the next number that has not been visited yet. So we pick 2, and see where that goes. 2 goes to 4, 4 goes to 6, 6 goes to 2; so that should give us \\( \\begin{pmatrix}2 \u0026 4 \u0026 6\\end{pmatrix}\\). Now add this cycle to the existing cycles like so:\n$$ \\begin{pmatrix} 1 \u0026 5 \\end{pmatrix} \\begin{pmatrix} 2 \u0026 4 \u0026 6 \\end{pmatrix} $$And then we move to the next number that is not already in a cycle, which is 3; and we see that 3 goes to itself, so we can leave it out.\nThen the next number that we haven\u0026rsquo;t visited yet is 7. If we follow 7 then we see that 7 goes to 9 and then goes back to 7, giving us:\n$$ \\begin{pmatrix} 1 \u0026 5 \\end{pmatrix} \\begin{pmatrix} 2 \u0026 4 \u0026 6 \\end{pmatrix} \\begin{pmatrix} 7 \u0026 9 \\end{pmatrix} $$Finally, the last number we need to visit is 8, but 8 just maps back to itself so we leave it as is.\nUsing cycle notation is generally preferred over tabular form as it takes up less space, and it also represents a core feature of the permutation in a better way. Using disjoint cycles is really handy so we will continue with this format primarly, but feel free to use tabular form as well to help you understand cycle form. Note also that compositions of non-disjoint cycles is perfectly valid too, but we prefer to use disjoint cycles whenever possible.\nInverses and the Identity Permutation # Every permutation has an inverse permutation. For every permutation \\(\\sigma\\), there exists an identity permutation which we denote \\(\\sigma^{-1}\\), such that the following holds:\n$$ \\sigma^{-1} \\circ \\sigma = \\sigma \\circ \\sigma^{-1} = e $$The proof that every permutation has an inverse follows from the fact that permutations are bijective functions from a set to itself. Every bijective function has an inverse, and since permutations are from a set to itself; then that inverse is also a permutation. The inverse is also unique, but we\u0026rsquo;ll not prove that.\nLet\u0026rsquo;s take the following permutation \\(\\sigma\\) as an example:\n$$ \\begin{pmatrix} 1 \u0026 4 \\end{pmatrix} \\begin{pmatrix} 3 \u0026 7 \u0026 5 \\end{pmatrix} $$The inverse of this permutation is \\( \\begin{pmatrix}1 \u0026 4\\end{pmatrix}\\begin{pmatrix}3 \u0026 5 \u0026 7\\end{pmatrix} \\) as:\n$$ \\begin{pmatrix} 1 \u0026 4 \\end{pmatrix} \\begin{pmatrix} 3 \u0026 7 \u0026 5 \\end{pmatrix} \\begin{pmatrix} 1 \u0026 4 \\end{pmatrix} \\begin{pmatrix} 3 \u0026 5 \u0026 7 \\end{pmatrix} = e $$Recall that cycle composition is from right-to-left. Take every number from 1 to 7 and move it from right to left across these 4 cycles, and you will see that the number ends up back at itself.\nFor example: 1 goes to 4 in \\( \\begin{pmatrix}1 \u0026 4\\end{pmatrix} \\), 4 stays fixed in \\( \\begin{pmatrix}3 \u0026 7 \u0026 5\\end{pmatrix} \\), 4 goes to 1 in \\( \\begin{pmatrix}1 \u0026 4\\end{pmatrix} \\), and 1 stays fixed in \\( \\begin{pmatrix}3 \u0026 5 \u0026 7\\end{pmatrix} \\). So, 1 goes to 1, itself. The same is true for every other number.\nIf we go back to using tabular form, then there is similar \u0026ldquo;trick\u0026rdquo; to finding out what the inverse of any permutation is. First, let\u0026rsquo;s take this same example and convert it to tabular form:\n$$ \\begin{pmatrix} 1 \u0026 4 \\end{pmatrix} \\begin{pmatrix} 3 \u0026 7 \u0026 5 \\end{pmatrix} = \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6 \u0026 7\\\\ 4 \u0026 2 \u0026 7 \u0026 1 \u0026 3 \u0026 6 \u0026 5 \\end{bmatrix} $$To find the inverse in tabular form, simply swap the top row and the bottom row:\n$$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6 \u0026 7\\\\ 4 \u0026 2 \u0026 7 \u0026 1 \u0026 3 \u0026 6 \u0026 5 \\end{bmatrix}^{-1} = \\begin{bmatrix} 4 \u0026 2 \u0026 7 \u0026 1 \u0026 3 \u0026 6 \u0026 5\\\\ 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6 \u0026 7 \\end{bmatrix} $$If you want, you can then swap the columns around so that the top row is ordered from 1,2,3,\u0026hellip; and so on, just like this:\n$$ \\begin{bmatrix} 4 \u0026 2 \u0026 7 \u0026 1 \u0026 3 \u0026 6 \u0026 5\\\\ 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6 \u0026 7 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 4 \u0026 5 \u0026 6 \u0026 7\\\\ 4 \u0026 2 \u0026 5 \u0026 1 \u0026 7 \u0026 6 \u0026 3 \\end{bmatrix} $$You can verify that this indeed does give you the inverse.\nThe inverse of an inverse is itself, i.e. \\((\\sigma^{-1})^{-1} = \\sigma\\), and this is true for any function (that is invertible).\nAlso, the inverse of any 2-cycle is itself, so \\( \\begin{pmatrix}a \u0026 b\\end{pmatrix}^{-1} = \\begin{pmatrix}a \u0026 b\\end{pmatrix} \\) for any numbers \\(a\\) and \\(b\\).\nExtended Compositions # One thing we can do is compose a permutation with itself, i.e. \\(\\sigma \\circ \\sigma\\), which leads to some interesting results. As a shorthand we write: \\(\\sigma \\circ \\sigma = \\sigma^2\\), understanding that the superscript here refers to composition and NOT exponentiation.\nWe can generalize this to any integer \\(n \u003e 0\\) so that:\n$$ \\sigma^n = \\underbrace{\\sigma \\circ \\sigma \\circ \\cdots \\circ \\sigma}_\\text{$n$ times} $$we can extend to the number 0 by defining:\n$$ \\sigma^0 = e $$and, we can also extend into the negative integers by defining the following:\n$$ \\sigma^{-n} = (\\sigma^{-1})^n = \\underbrace{\\sigma^{-1} \\circ \\sigma^{-1} \\circ \\cdots \\circ \\sigma^{-1}}_\\text{$n$ times} $$where \\(n \u003e 0\\).\nWith this cool notation, we have found a way to use any integers \\(k\\) and \\(r\\), negative or non-negative, so that the following expressions are well-defined and true:\n$$ \\sigma^k \\circ \\sigma^r = \\sigma^{k + r}, (\\sigma^k)^r = \\sigma^{kr} $$This gives us the ability to \u0026ldquo;treat\u0026rdquo; compositions similar to exponent rules as seen in normal arthmetic. Of course, our superscript notation is NOT exponentiation, but it behaves similar to exponent rules.\nAn interesting question might be to ask for what values of \\(k\\) does \\(\\sigma^k = e\\), if any at all. The answer is that this is true for any finite permutation.\nIf you think about, there cannot be an infinite amount of different permutations generated by a permutation being composed with itself over and over again. Eventually, it will have to start repeating itself, as there are only \\(n!\\) possible permutations. This means that there exists an integer \\(k\\) such that \\(\\sigma^k = \\sigma\\). And in fact, if this is true then we can prove that:\n$$ \\begin{align} \\sigma^k \u0026= \\sigma\\\\ \\Longrightarrow \\sigma^{-1} \\circ \\sigma^k \u0026= \\sigma^{-1} \\circ \\sigma\\\\ \\Longrightarrow \\sigma^{k-1} \u0026= e \\end{align} $$So we can state as a theorem that for every finite permutation, there exists an integer \\(r\\) such that \\(\\sigma^r = e\\), \\(\\sigma^{r-1} = \\sigma^{-1}\\), and \\(\\sigma^{r+1} = \\sigma \\). This means that every permutation, when repeatedly applied over and over again, will eventually just lead all numbers back to themselves.\nLet us define the set of all self compositions of \\(\\sigma\\) as: \\(\\langle \\sigma \\rangle\\), which is defined as:\n$$ \\langle \\sigma \\rangle\\ = \\{\\sigma^n | n \u003e 0\\} $$We restrict \\(n\\) to be greater than 0, but this is not neccessary. We could say it\u0026rsquo;s less than or equal to 0, or we could just let it be any integer. All these choices will create the same set, as the set of self-compositions is cyclic. You could go backwards or forwards but it doesn\u0026rsquo;t matter, you\u0026rsquo;ll get the same results whichever direction you pick and whatever element you start with.\nIn fact, because of the cyclic nature of this set, we only need to specify an integer range that needs to be at least greater or equal to the number of elements in \\(\\langle \\sigma \\rangle\\).\nWe define the order of \\(\\sigma\\), denoted by \\(|\\sigma|\\), to be the smallest positive integer \\(k\\) such that \\(\\sigma^k = e\\). Therefore:\n$$ |\\sigma| = |\\langle \\sigma \\rangle| $$And so we can give an equivalent definition for \\(\\langle \\sigma \\rangle\\) as so:\n$$ \\langle \\sigma \\rangle = \\{\\sigma^k | k \\in [a,b) \\land |b - a| = | \\sigma | \\} $$This notation is confusing for many reasons so I\u0026rsquo;ll break it down:\n\\(a\\) and \\(b\\) are any integers \\(|\\sigma|\\) refers to the order of \\(\\sigma\\), whereas \\(|b - a|\\) refers to the absolute value of \\(b-a\\). The differing parentheses in \\([a,b)\\) is done on purpose so that \\(b\\) is not included. Otherwise, if we used the range \\([a,b]\\) instead, then we would have to require that \\(b - a + 1 = | \\sigma| \\). Try to understand this \u0026ldquo;cyclic\u0026rdquo; notion well, because it is a critical aspect of not just permutations but any group in general.\nArray \u0026amp; ODC Form # So far we\u0026rsquo;ve mentioned two main ways to represent permutations: tabular form and cycle form. Both of these representations have the property that there is more than one possible way of representing the same exact permutation.\nIn tabular form, it is possible to reorder columns freely without changing the permutation. In cycle form, we observed that disjoint cycles compose in any order that we like. Not only that, but the numbers within cycles can be re-ordered to start at any of the elements.\nIn order to introduce form that has a single representation per permutation, we will introduce array form and ordered disjoint cycle form.\nArray form is written as so:\n$$ \\begin{bmatrix} a_1 \u0026 a_2 \u0026 a_3 \u0026 \\cdots \u0026 a_n \\end{bmatrix} $$Where \\(n\\) is the amount of numbers to be permuted, and every \\(a_i\\) is unique and belongs to the set \\(\\{1,2,...,n\\}\\), and the permutation of the array form \\(\\tau\\) is given by:\n$$ \\forall i \\in \\{1,2,...,n\\} : \\tau(i) = a_i $$This can be best understood as imagining that there is a row above the array that has the numbers 1,2,3,\u0026hellip;,n in order so that the following is true:\n$$ \\begin{bmatrix} a_1 \u0026 a_2 \u0026 a_3 \u0026 \\cdots \u0026 a_n \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 \\cdots \u0026 n\\\\ a_1 \u0026 a_2 \u0026 a_3 \u0026 \\cdots \u0026 a_n \\end{bmatrix} $$This basically just gives us a shorthand as opposed to tabular form. Array form is especially useful for computation as you can simply store vectors all of size \\(n\\) and easily compute compositions with very simple algorithms. The downside is that array form (like tabular form) is very \u0026ldquo;wasteful\u0026rdquo; when we have a lot of 1-cycles. Consider this example:\n$$ \\begin{pmatrix} 4 \u0026 9 \\end{pmatrix} = \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 9 \u0026 5 \u0026 6 \u0026 7 \u0026 8 \u0026 4 \\end{bmatrix} $$It\u0026rsquo;s not hard to see how array form could be a huge waste of memory over the much more memory-conservative cycle form. There are ways you could further optimize array form by using some kind of compression like run-length encoding for runs of 1-cycles, but we won\u0026rsquo;t go over that in this post.\nWe can also use ordered disjoint cycle form or just \u0026ldquo;ODC\u0026rdquo; for short, which is simply just using disjoint cycles where each cycle starts with the least number in that cycle. Since compositions of disjoint cycles can be rearranged, we also order the cycles by least starting element to greatest starting element.\nTake this as an example conversion from normal cycle form to ODC form:\n$$ \\begin{pmatrix} 5 \u0026 3 \\end{pmatrix} \\begin{pmatrix} 6 \u0026 2 \u0026 1 \\end{pmatrix} \\begin{pmatrix} 4 \u0026 9 \\end{pmatrix} = \\begin{pmatrix} 1 \u0026 6 \u0026 2 \\end{pmatrix} \\begin{pmatrix} 3 \u0026 5 \\end{pmatrix} \\begin{pmatrix} 4 \u0026 9 \\end{pmatrix} $$ODC form also has the nice property that there is unique representation for every permutation, so we can compare two permutations in ODC form very easily to see if they are equal by simply iterating linearly over the numbers. The disadvantage with ODC compared to Array form is that with ODC, we need to store a list of lists to represent the cycles, which is more complex than just a single linear array. The tradeoff here is that ODC saves a lot more memory, and compositions with ODC can potentially be computed with significantly less iterations.\nTranspositions # The last thing I want to cover in this post are transpositions, which is simply just another name for a 2-cycle, i.e. \\( \\begin{pmatrix}a \u0026 b\\end{pmatrix} \\). We give 2-cycles this special name because of a very special property: every permutation can be represented as a composition of transpositions.\nTo prove this, we observe that the following is true for any k-cycle:\n$$ \\begin{pmatrix} a_1 \u0026 a_2 \u0026 a_3 \u0026 \\cdots \u0026 a_{k-1} \u0026 a_{k} \\end{pmatrix} = \\begin{pmatrix} a_1 \u0026 a_k \\end{pmatrix} \\begin{pmatrix} a_1 \u0026 a_{k-1} \\end{pmatrix} \\cdots \\begin{pmatrix} a_1 \u0026 a_3 \\end{pmatrix} \\begin{pmatrix} a_1 \u0026 a_2 \\end{pmatrix} $$The composition of these transpositions certainly aren\u0026rsquo;t disjoint (as \\(a_1\\) appears in all of them), but they will equal the original cycle.\nThe next step in the proof is to realize that every permutation can be represented as a combination of cycles, which we have already implicity assumed. Then, if you take each cycle, simply replace it with it\u0026rsquo;s equivalent composition of transpositions. The whole expression will then be one giant composition of transpositions, and it will be equal to the original permutation!\nThis result is useful because it means we can always represent a permutation as a series of \u0026ldquo;swaps\u0026rdquo;. In other words, every permutation is just taking a list of things and swapping them around some number of times.\n","date":"9 March 2025","externalUrl":null,"permalink":"/posts/group_theory_part_1/","section":"Posts","summary":"","title":"Introduction to Group Theory Part 1: Permutations","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]